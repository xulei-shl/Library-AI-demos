# 技术设计: 提取艺术风格检测模块

## Context

当前系统架构采用模块化管道设计,每个处理阶段作为独立模块存在于 `src/core/stages/` 目录下。艺术风格识别当前嵌入在 `fact_description` 阶段中,与其他 11 个元数据字段一起由单个 VLM 调用提取。

### 背景约束

1. **模型成本**: 每次 VLM 调用成本较高(视觉模型超时 180 秒,API 费用)
2. **数据质量**: 缺乏标准化词表导致艺术风格标签不一致
3. **模块职责**: 事实描述阶段职责过重,包含 12 个不同维度的元数据提取
4. **兼容性要求**: 现有下游系统依赖固定的 JSON 输出格式

### 利益相关者

- **数据分析人员**: 需要一致的艺术风格标签用于统计分析
- **系统维护人员**: 需要清晰的模块边界便于后续优化
- **API 调用成本**: 需要在模型调用次数和数据质量之间平衡

---

## Goals / Non-Goals

### Goals

1. **标准化艺术风格输出**: 通过受控词表确保数据一致性
2. **模块职责分离**: 将艺术风格识别独立为单一职责模块
3. **保持向后兼容**: 不改变现有 JSON 输出格式
4. **最小化模型调用**: 在不显著增加成本的前提下提高质量

### Non-Goals

1. **不引入多模态融合**: 仍使用单一 VLM 调用,不进行跨模型集成
2. **不重构整个管道**: 仅针对艺术风格检测进行提取,其他阶段保持不变
3. **不改变图像分组逻辑**: 保持现有 a_series/a_object/b 类型分组策略
4. **不实现艺术风格的自动纠错**: 纠错阶段(correction)仍专注于文本字段

---

## Decisions

### Decision 1: 新建独立阶段模块 vs. 在事实描述中增强约束

**选择**: 新建独立阶段模块 `art_style.py`

**理由**:
1. **职责分离**: 艺术风格识别是一个独立的视觉分析任务,与事实描述的其他字段(如国家、厂商、文字内容)属于不同的认知维度
2. **提示词优化**: 独立模块可以使用专门的提示词,包含完整的艺术风格词表和详细的视觉识别指导,而不会使事实描述提示词过长
3. **可维护性**: 未来如需优化艺术风格识别逻辑(如引入专用的图像分类模型),独立模块更易于替换
4. **元数据追踪**: 每个阶段生成独立的 `*_meta` 字段,便于追踪艺术风格识别的成功率和模型调用情况

**替代方案考虑**:
- **方案 A**: 在事实描述提示词中添加艺术风格词表 → **拒绝**,原因是提示词已经很长(207 行),增加词表会影响模型的关注焦点
- **方案 B**: 在纠错阶段(correction)中添加艺术风格标准化 → **拒绝**,原因是纠错阶段是文本模型,无法访问图像进行视觉分析

---

### Decision 2: 阶段执行顺序

**选择**: 事实描述 → 艺术风格检测 → 功能类型 → 纠错 → 系列分析

**理由**:
1. **数据依赖**: 艺术风格检测仅需要图像输入,不依赖事实描述的结果,但放在事实描述之后可以让模型专注于视觉风格判断
2. **成本优化**: 如果事实描述失败,可以直接跳过后续阶段,节省 API 调用
3. **逻辑顺序**: 先提取客观事实,再进行风格判断,符合人类的认知流程

**替代方案考虑**:
- **方案 A**: 事实描述和艺术风格并行调用 → **拒绝**,原因是无法共享单次 VLM 调用,反而增加成本
- **方案 B**: 艺术风格检测在功能类型之后 → **可行但次优**,当前顺序更符合"基础属性 → 高级分类"的逻辑

---

### Decision 3: 艺术风格词表的粒度

**选择**: 13 个标准分类(包括"其他")

**理由**:
1. **覆盖常见类型**: 基于现有火花样本分析,13 个类别可覆盖 95% 以上的常见风格
2. **平衡精度与可用性**: 过细的分类(如区分"水彩画"和"水粉画")对非专业用户意义不大,反而增加模型判断难度
3. **预留扩展性**: "其他"类别允许处理罕见或混合风格

**替代方案考虑**:
- **方案 A**: 开放式文本输入(当前方案) → **拒绝**,无法保证一致性
- **方案 B**: 30+ 个细分类别 → **拒绝**,过于复杂,VLM 容易混淆相似类别

---

### Decision 4: VLM 模型选择

**选择**: 使用与事实描述相同的视觉模型(primary: ModelScope Qwen3-VL-235B, secondary: Qwen3-VL-Plus)

**理由**:
1. **已验证性能**: 这些模型在事实描述任务中表现良好,具有强大的视觉理解能力
2. **成本一致性**: 保持与现有阶段相同的成本结构
3. **故障转移**: 利用现有的主辅模型切换机制

**替代方案考虑**:
- **方案 A**: 使用轻量级图像分类模型(如 ResNet + 微调) → **未来优化方向**,当前阶段优先保持架构一致性
- **方案 B**: 使用文本模型基于事实描述结果推断 → **拒绝**,缺乏视觉特征会降低准确性

---

## Risks / Trade-offs

### Risk 1: 增加 VLM 调用次数导致成本上升

**影响**: 每个图像组额外增加一次 VLM 调用(约 180 秒超时)

**缓解措施**:
- 艺术风格检测使用更低的 `temperature` 参数(0.2),提高确定性并减少重试概率
- 如果成本成为问题,可在未来阶段引入轻量级模型替换
- 通过词表约束,提高首次调用成功率,减少重试次数

**接受度**: 可接受,因为数据质量提升的价值大于单次调用成本

---

### Risk 2: 模型可能无法准确匹配词表中的类别

**影响**: VLM 可能输出不在词表中的值,导致验证失败

**缓解措施**:
- 在提示词中明确要求 **严格从词表中选择**
- 使用 JSON schema 输出验证
- 提供详细的视觉识别要点和示例,帮助模型理解每个类别

**接受度**: 可接受,通过提示词工程和充分的词表描述可显著降低此风险

---

### Trade-off: 模块独立性 vs. 处理效率

**选择**: 优先模块独立性

**理由**:
- 长期维护价值高于短期效率损失
- 未来可通过批处理或模型优化降低成本
- 清晰的模块边界有利于团队协作和功能迭代

---

## Migration Plan

### 实施步骤

1. **阶段 1: 创建新模块**(不影响现有功能)
   - 新建 `src/core/stages/art_style.py`
   - 新建 `src/prompts/art_style.md`
   - 新建 `docs/metadata/艺术风格词表.md`
   - 在 `config/settings.yaml` 中添加 `art_style` 任务配置

2. **阶段 2: 集成到管道**(需要测试验证)
   - 修改 `src/core/pipeline.py`,在事实描述后调用艺术风格检测
   - 将检测结果合并到 `fact_json["art_style"]`
   - 添加 `fact_json["art_style_meta"]` 元数据

3. **阶段 3: 清理旧逻辑**(确保新模块稳定后执行)
   - 从 `src/prompts/fact_description.md` 移除艺术风格词条(第 126-129 行)
   - 从 `src/prompts/fact_description-noseries.md` 移除艺术风格词条(第 111-114 行)
   - 从输出 schema 中移除 `art_style` 字段(新模块会重新添加)

### 回滚策略

如果新模块表现不佳:
1. 暂时禁用艺术风格检测阶段(在 `pipeline.py` 中注释相关代码)
2. 恢复事实描述提示词中的艺术风格指令
3. 保留词表文档作为参考,但不强制使用

### 数据兼容性

- **新旧数据对比**: 运行新模块后,对比新旧方式提取的艺术风格标签,分析差异
- **渐进式替换**: 可选择性地对部分图像组启用新模块,观察效果后全面推广

---

## Open Questions → Decisions

### Question 1: 是否需要在纠错阶段添加艺术风格验证?

**决策**: **暂时不需要**

**理由**:
- 纠错阶段专注于基于文本内容的结构化字段验证
- 艺术风格是视觉判断任务,纠错阶段的文本模型无法有效验证
- 当前优先级是确保艺术风格检测模块本身的准确性
- 如未来需要验证,可在艺术风格检测阶段内部实现(例如,要求 VLM 提供置信度分数)

---

### Question 2: 是否需要支持多风格标签?

**决策**: **支持 1-2 个主导风格,使用 `List<String>` 格式**

**理由**:
- 某些火花确实混合多种艺术风格(例如,年画风格 + 工笔画)
- 限制为 1-2 个可避免过度标注,同时保留关键风格信息
- 在提示词中指导 VLM 按视觉占比排序,优先选择最主导的风格

**实施变更**:
- 输出 schema 从 `"art_style": "String | null"` 改为 `"art_style": ["String"] | null`
- 提示词明确要求:最多选择 2 个风格,按主导程度排序
- 单一风格时仍返回列表格式(例如 `["写实绘画"]`)

---

### Question 3: 词表是否需要定期更新?

**决策**: **需要定期更新,并采用双字段方案**

**方案**: **规范词 + 自由词双字段输出**

**具体实现**:
1. **JSON 输出包含两个字段**:
   - `art_style`: `List<String> | null` - 从 13 个标准词表中选择的规范分类(1-2 个)
   - `art_style_raw`: `List<String> | null` - VLM 自由描述的艺术风格词(当规范词表无法精确覆盖时使用)

2. **VLM 提取逻辑**:
   - **优先匹配规范词表**: 如果火花风格符合 13 个标准分类之一,填充 `art_style` 字段
   - **无法匹配时使用自由词**: 如果无法归入任何标准分类,`art_style` 填写 `["其他"]`,并在 `art_style_raw` 中给出具体描述(例如 `["赛璐璐动画风格"]`)
   - **可同时使用**: 允许同时填充两个字段,`art_style_raw` 作为规范词的补充说明

3. **词表更新策略**:
   - 每季度分析 `art_style_raw` 中的高频词汇
   - 如果某个自由词出现频率 > 5%,考虑将其纳入标准词表
   - 更新词表后,重新处理历史数据中标记为"其他"的记录

**优势**:
- **数据规范性**: 保持 `art_style` 字段的可控性和可比性
- **灵活性**: 通过 `art_style_raw` 捕获长尾风格,避免信息丢失
- **演进能力**: 通过分析自由词逐步完善标准词表
