# 设计文档：系列级元数据一致性共识机制

## Context

### 背景
Matchbox 系统用于分析和编目火花（火柴盒标签）图像。图像按系列组织，每个系列包含多组对象图像。当前实现中，系统对每组图像独立调用 VLM 生成元数据，导致同一系列下不同组的系列级字段（如厂商、国家、艺术风格）可能出现不一致。

### 约束
- 必须支持断点续传：用户可能在不同时间批次向系列文件夹添加新图片
- 必须向后兼容：不能破坏现有输出格式和已处理数据
- 需要控制 API 成本：不能对所有组都进行多次调用
- 文件系统限制：共识文件存储在输入目录（可能只读或受版本控制）

### 利益相关者
- 用户：需要准确、一致的系列元数据用于归档和检索
- 系统维护者：需要清晰的代码结构和可维护性
- API 提供商：需要合理控制调用量

## Goals / Non-Goals

### Goals
- 保证同一系列的系列级字段（`manufacturer`, `country`, `art_style`, `series.name`）在所有对象组间保持一致
- 支持增量处理：后续新增图片时自动继承已有共识，无需重新计算
- 降低单次 VLM 错误的影响：通过多组采样和 LLM 投票提高准确性
- 保持现有架构的模块化设计：共识逻辑封装为独立阶段

### Non-Goals
- 不对对象级字段（`theme`, `inferred_era` 等）进行一致性约束
- 不修改已生成的历史数据
- 不支持跨系列的全局一致性检查
- 不在本次变更中实现共识结果的人工校验 UI（可作为未来增强）

## Decisions

### 决策 1：共识文件存储位置
**选择**: 存储在系列文件夹内（`pic/S1/.series_consensus.json`）

**理由**:
- 与源数据紧密关联，便于理解和管理
- 支持版本控制（如果输入目录在 git 中）
- 简化路径映射逻辑

**替代方案考虑**:
- 存储在 `runtime/outputs/.consensus/` 下：需要额外的路径映射，且在清理输出目录时可能丢失

**权衡**:
- 缺点：需要对输入目录有写权限
- 缓解：如果输入目录只读，在首次写入时失败并给出清晰错误提示

### 决策 2：共识策略 - 多组聚合 + LLM 投票
**选择**: 对前 3 组分别调用 VLM，然后通过专门的 `series_consensus` LLM 任务进行投票

**理由**:
- 平衡准确性和成本：3 组样本足以覆盖系列多样性，同时避免过多 API 调用
- 利用 LLM 的语义理解能力：比简单的"最频繁值"更智能，能处理同义词、格式差异等
- 可解释性：LLM 输出包含 `reasoning` 字段，便于调试和审计

**替代方案考虑**:
- 首组推断：成本最低，但单点失败风险高
- 简单投票（最频繁值）：无法处理格式差异（如"中国" vs "China"）

**权衡**:
- 增加 1 次额外的 LLM 调用（文本任务，成本较低）
- 前 3 组需要等待共识计算完成后才能写入最终 JSON

### 决策 3：字段分层
**选择**: 明确区分系列级和对象级字段

- **系列级（必须一致）**: `series.name`, `manufacturer`, `country`, `art_style`
- **对象级（允许差异）**: `theme`, `inferred_era`, `description`, `elements`, `dominant_colors`, `text_content`, `layout_composition`

**理由**:
- 符合领域语义：同一系列由同一厂商、同一国家、同一风格生产
- `theme` 允许差异：系列主题可能宽泛（如"中国名胜"），而对象主题更具体（如"建筑"、"自然景观"）
- `inferred_era` 允许差异：某些系列可能跨越多个年代

**权衡**:
- 如果用户期望 `theme` 也保持一致，可以在后续迭代中调整

### 决策 4：共识文件格式
**选择**: JSON 格式，包含共识结果和元数据

```json
{
  "series_name": "中国名胜",
  "manufacturer": "北京火柴厂",
  "country": "中国",
  "art_style": "写实风景画",
  "consensus_source": ["A001", "A002", "A003"],
  "consensus_meta": {
    "created_at": "2025-10-19T14:30:00+08:00",
    "llm_model": "DeepSeek-V3.2-Exp",
    "consensus_strategy": "llm_vote",
    "sample_size": 3
  }
}
```

**理由**:
- 可追溯：记录共识来源和生成时间
- 可扩展：未来可添加置信度、投票详情等字段

### 决策 5：A 类型和 B 类型的统一处理
**选择**: A 类型和 B 类型使用相同的共识机制，但 A 类型的 `series.name` 继续从 series 样本提取

**理由**:
- 代码逻辑统一，降低复杂度
- A 类型已有明确的系列图像，无需对 `series.name` 进行共识
- 其他字段（`manufacturer`, `country`, `art_style`）的共识逻辑完全一致

**实现细节**:
- A 类型：先处理 `series/` 样本获取 `series.name`，再对前 3 个对象组进行共识计算
- B 类型：直接对前 3 组进行共识计算，包含 `series.name`

## Risks / Trade-offs

### 风险 1：共识文件丢失或损坏
**风险**: 如果 `.series_consensus.json` 被误删或损坏，系统会重新计算共识，可能产生不同结果

**缓解**:
- 在共识文件中记录 `consensus_source`，用户可根据来源组 ID 验证一致性
- 在日志中记录共识文件的创建和读取操作
- 未来可考虑将共识结果同步到数据库或云存储

### 风险 2：前 3 组不具代表性
**风险**: 如果前 3 组图像质量差或不典型，共识结果可能有偏差

**缓解**:
- 用户应确保图像按合理顺序组织（建议将高质量、典型图像放在前面）
- 提供配置项 `force_recalculate_consensus` 允许用户重新计算
- 在共识提示词中指导 LLM 优先选择有明确证据的值，而非猜测

### 风险 3：API 成本增加
**风险**: 对前 3 组分别调用 VLM + 1 次共识 LLM，增加约 33% 的调用量（相比原先只处理 3 组的情况）

**缓解**:
- 共识任务使用文本模型（成本远低于视觉模型）
- 后续组节省了系列级字段的生成，可能减少视觉模型的推理复杂度
- 配置项 `sample_size` 允许用户调整样本数量（默认 3，可降至 2 或升至 5）

### 权衡 4：输入目录写权限要求
**权衡**: 共识文件存储在输入目录，要求该目录可写

**影响**:
- 如果输入目录挂载为只读，系统将无法保存共识文件
- 需要在文档中明确说明该要求

**缓解**:
- 在首次尝试写入时捕获异常，给出友好错误提示
- 未来可考虑支持通过配置指定共识文件的备用存储路径

## Migration Plan

### 阶段 1：实现核心逻辑（本次变更）
1. 创建 `series_consensus` 阶段模块和提示词
2. 修改 `pipeline.py` 编排逻辑，增加共识检查和生成步骤
3. 新增工具函数：读写共识文件、字段合并
4. 配置新增 `series_consensus` 任务

### 阶段 2：测试和验证
1. 使用测试数据集（包含 A 类型和 B 类型）验证共识逻辑
2. 验证断点续传：在系列中新增图片后重新运行，确保继承共识
3. 验证边界情况：少于 3 组的系列、共识文件损坏等

### 阶段 3：部署和回滚计划
- **部署**: 更新代码和配置，文档说明新行为
- **回滚**: 如果共识机制出现严重问题，可通过配置禁用（添加 `enable_series_consensus: false`）并回退到逐组独立生成

### 阶段 4：未来增强（不在本次变更范围）
- 共识结果的人工校验界面
- 支持跨系列的全局厂商/国家规范化
- 共识置信度评分和质量指标

## Open Questions

### Q1: 是否需要对少于 3 组的系列进行特殊处理？
**建议**: 如果系列只有 1-2 组，直接使用这些组的数据生成共识，不调用投票 LLM（单组直接采纳，双组取交集或首组）

### Q2: 是否需要支持强制重新计算共识的命令行参数？
**建议**: 在配置中添加 `force_recalculate_consensus: false`，当设为 `true` 时忽略已有共识文件

### Q3: B 类型如何判断系列边界？
**当前假设**: 子文件夹即系列（如 `pic/S1/` 下所有图像属于同一系列）
**确认**: 这是否符合实际使用场景？是否需要支持更复杂的系列识别逻辑（如基于文件名前缀的子系列）？

**用户已确认**: 子文件夹即系列，人工组织，无需代码判断。
