# 书海回响 - 第二模块：智能降噪模块设计方案（最终版）

## 1. 项目背景
基于第一模块"借阅数据分析"的输出结果，需要实现第二模块"智能降噪"功能，剔除"显性"图书，为后续的"再发现"分析做准备。

## 2. 核心目标
- **规则A**：排除顶流热门（前15%借阅次数最高的图书）
- **规则B**：排除特定类型图书（技术类、教辅类、考试类、娱乐类）
- **规则C**：Excel列值筛选（附加信息格式校验、备注关键词排除等）
- 支持可配置的筛选条件（题名关键词、索书号模式等）
- 支持多种匹配方式（包含匹配、开头匹配、正则表达式）
- **模块化设计**：便于灵活新增筛选规则，原子化实现

## 3. 实施方案详细设计

### 3.1 筛选阈值确定

#### 3.1.1 动态阈值计算方法
基于v4版本的动态阈值策略，适应不同月份的数据分布：

```yaml
rule_a:
  enabled: true
  target_column: "近四个月总次数"  # 明确指定统计列名
  methods:
    # 方法1：分位数方法（推荐）
    percentile:
      enabled: true
      threshold_percentile: 15  # 前15%
      fallback_count: 20  # 数据量不足时的后备阈值

    # 方法2：绝对次数方法
    absolute_count:
      enabled: false
      threshold_borrowing_count: 20

    # 方法3：统计分布方法
    distribution:
      enabled: false
      exclude_top_buckets: 3  # 排除最高的3个借阅次数区间
```

#### 3.1.2 动态阈值算法
```python
def calculate_dynamic_threshold(data: pd.DataFrame, percentile: float = 15) -> int:
    """动态计算前N%借阅次数阈值"""

    # 获取非零借阅次数的索书号
    non_zero_data = data[data['近四个月总次数'] > 0]

    if len(non_zero_data) == 0:
        return 20  # 默认后备值

    # 使用分位数计算阈值
    threshold = np.percentile(non_zero_data['近四个月总次数'], 100 - percentile)

    # 如果分位数结果过小，使用统计特征
    if threshold < 5:
        threshold = np.percentile(non_zero_data['近四个月总次数'], 75)

    return int(threshold)
```

### 3.2 配置文件结构设计

#### 3.2.1 主配置文件 (config/setting.yaml)
```yaml
# 第二模块筛选配置
filtering:
  # 规则A：排除顶流热门
  rule_a:
    enabled: true
    target_column: "近四个月总次数"
    methods:
      percentile:
        enabled: true
        threshold_percentile: 15
        fallback_count: 20
      absolute_count:
        enabled: false
        threshold_borrowing_count: 20

  # 规则B：排除特定类型（整合后版本）
  rule_b:
    # 题名关键词筛选（合并_contains和_starts版本）
    title_keywords:
      enabled: true
      description: "题名关键词排除"
      target_column: "题名"
      file: "config/filters/title_keywords.txt"
      match_type: "contains"  # contains, starts_with, ends_with, regex

    # 索书号/CLC号筛选（合并版本，统一处理）
    call_number_clc:
      enabled: true
      description: "索书号和CLC号模式排除"
      # 支持多个列名映射
      target_columns: ["索书号", "CLC号"]
      file: "config/filters/call_number_clc.txt"
      match_type: "regex"  # regex, contains, starts_with, ends_with

  # 规则C：Excel列值筛选
  rule_c:
    # 附加信息列筛选
    additional_info_format:
      enabled: true
      description: "附加信息9位数字格式校验"
      target_column: "附加信息"
      filter_type: "regex"
      pattern: "^[0-9]{9}"
      action: "keep_only"  # keep_only 或 exclude

    # 备注列筛选
    remarks_keywords:
      enabled: true
      description: "备注列排除指定关键词"
      target_column: "备注"
      filter_type: "exclude_contains"
      exclude_patterns: ["不要", "废书", "损坏"]
      action: "exclude"

    # 类型/册数列筛选
    type_exclude:
      enabled: true
      description: "类型/册数列排除指定内容"
      target_column: "类型/册数"
      filter_type: "exclude_contains"
      exclude_patterns: ["期刊", "视听", "DVD"]
      action: "exclude"
```

#### 3.2.2 筛选条件文件（简化版）

**config/filters/title_keywords.txt** - 题名关键词筛选（统一版本）
```
# 题名关键词筛选 - 统一版本
# 每行一个关键词
# 匹配方式：在setting.yaml中配置（contains/starts_with/ends_with/regex）

# 技术类
Python
Java
JavaScript
机器学习
人工智能
编程
算法
数据库
网页设计
软件开发

# 教辅类
考试
教程
教材
习题
答案
题解
模拟题
真题

# 专业类
医学
法律
会计
工程
建筑
财务
管理
营销
```

**config/filters/call_number_clc.txt** - 索书号和CLC号模式筛选（合并版本）
```
# 索书号和CLC号模式筛选 - 合并版本
# 每行一个模式（支持正则表达式）
# 匹配方式：在setting.yaml中配置（regex/contains/starts_with/ends_with）

# 技术类索书号/CLC模式
TP[0-9]+  # 计算机技术类
TN[0-9]+  # 无线电电子学类
TS[0-9]+  # 轻工业手工业类
TQ[0-9]+  # 化学工业类

# 教辅类
G[0-9]+-[0-9]+  # 教育类
O[0-9]+-[0-9]+  # 数理化类

# 专业类
R[0-9]+-[0-9]+  # 医学类
D[0-9]+-[0-9]+  # 法律类
F[0-9]+-[0-9]+  # 经济类

# 常见的CLC分类号前缀
G[0-9]  # 文化、科学、教育、体育
TP[0-9] # 计算机技术
TN[0-9] # 无线电电子学、电信技术
R[0-9]  # 医药、卫生
D[0-9]  # 政治、法律
```

### 3.3 核心模块设计（模块化原子化）

#### 3.3.1 模块化筛选器结构
```
src/core/
├── data_filter.py       # 主要筛选器（最终版本）
├── filters/
│   ├── __init__.py
│   ├── base_filter.py         # 基础筛选器抽象类
│   ├── hot_books_filter.py    # 规则A：热门图书排除
│   ├── title_keywords_filter.py # 规则B：题名关键词筛选
│   ├── call_number_filter.py  # 规则B：索书号/CLC筛选（合并）
│   ├── column_value_filter.py # 规则C：Excel列值筛选
│   └── rule_config.py         # 规则配置管理
└── utils/
    ├── match_utils.py         # 通用匹配算法
    ├── column_utils.py        # 列名处理工具
    └── file_utils.py          # 配置文件加载工具
```

#### 3.3.2 基础筛选器抽象类
```python
from abc import ABC, abstractmethod
from typing import Dict, Any, Tuple, List
import pandas as pd

class BaseFilter(ABC):
    """基础筛选器抽象类 - 确保模块化设计"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.enabled = config.get('enabled', True)
        self.description = config.get('description', '')
        self.target_column = config.get('target_column')
        self.target_columns = config.get('target_columns', [self.target_column])
    
    @abstractmethod
    def apply(self, data: pd.DataFrame) -> Tuple[pd.DataFrame, Dict[str, Any]]:
        """应用筛选规则
        
        Returns:
            Tuple[pd.DataFrame, Dict]: (筛选后的数据, 统计信息)
        """
        pass
    
    def _validate_columns(self, data: pd.DataFrame) -> List[str]:
        """验证目标列是否存在"""
        available_columns = list(data.columns)
        valid_columns = []
        
        for col in self.target_columns:
            if col in available_columns:
                valid_columns.append(col)
            else:
                # 尝试自动映射列名
                mapped_col = self._auto_map_column(col, available_columns)
                if mapped_col:
                    valid_columns.append(mapped_col)
        
        return valid_columns
    
    def _auto_map_column(self, target: str, available: List[str]) -> str:
        """自动映射列名"""
        # 常见的列名映射
        mapping = {
            '索书号': ['索书号', '分类号', 'CallNumber', 'CallNo'],
            'CLC号': ['CLC号', '分类号', '分类号码', 'CLC'],
            '题名': ['题名', '书名', '图书名称', 'Title'],
            '附加信息': ['附加信息', 'AdditionalInfo', 'ExtraInfo'],
            '备注': ['备注', 'Remark', 'Notes'],
            '类型/册数': ['类型/册数', '类型', 'Type']
        }
        
        possible_names = mapping.get(target, [target])
        for name in possible_names:
            if name in available:
                return name
        return None
```

#### 3.3.3 动态加载筛选器机制
```python
class FilterRegistry:
    """筛选器注册表 - 支持动态新增筛选规则"""
    
    _filters = {}
    
    @classmethod
    def register(cls, filter_type: str, filter_class: type):
        """注册新的筛选器类型"""
        cls._filters[filter_type] = filter_class
    
    @classmethod
    def create_filter(cls, filter_type: str, config: Dict[str, Any]) -> BaseFilter:
        """根据类型创建筛选器实例"""
        if filter_type not in cls._filters:
            raise ValueError(f"未知的筛选器类型: {filter_type}")
        
        filter_class = cls._filters[filter_type]
        return filter_class(config)
    
    @classmethod
    def get_available_filters(cls) -> List[str]:
        """获取所有可用的筛选器类型"""
        return list(cls._filters.keys())

# 注册所有内置筛选器
FilterRegistry.register('hot_books', HotBooksFilter)
FilterRegistry.register('title_keywords', TitleKeywordsFilter)
FilterRegistry.register('call_number', CallNumberFilter)
FilterRegistry.register('column_value', ColumnValueFilter)
```

#### 3.3.4 主筛选器类
```python
class BookFilterFinal:
    """最终版图书筛选器 - 支持模块化和动态扩展"""
    
    def __init__(self, config_path: str = "config/setting.yaml"):
        self.config = self._load_config(config_path)
        self.filter_results = {}
        self._init_filters()
    
    def _init_filters(self):
        """初始化所有筛选器"""
        self.filters = []
        
        # 从配置文件动态创建筛选器
        for rule_name, rule_config in self.config['filtering'].items():
            if not isinstance(rule_config, dict):
                continue
                
            for filter_name, filter_config in rule_config.items():
                if isinstance(filter_config, dict) and filter_config.get('enabled', False):
                    try:
                        # 根据配置类型选择筛选器
                        filter_type = self._determine_filter_type(rule_name, filter_name)
                        filter_instance = FilterRegistry.create_filter(filter_type, filter_config)
                        self.filters.append((filter_name, filter_instance))
                    except Exception as e:
                        logger.warning(f"创建筛选器 '{filter_name}' 失败: {e}")
    
    def _determine_filter_type(self, rule_name: str, filter_name: str) -> str:
        """根据规则名称确定筛选器类型"""
        if rule_name == 'rule_a':
            return 'hot_books'
        elif rule_name == 'rule_b':
            if 'title' in filter_name.lower():
                return 'title_keywords'
            elif 'call_number' in filter_name.lower() or 'clc' in filter_name.lower():
                return 'call_number'
        elif rule_name == 'rule_c':
            return 'column_value'
        
        return 'column_value'  # 默认类型
    
    def filter_books(self, data: pd.DataFrame) -> pd.DataFrame:
        """执行完整的筛选流程"""
        result_data = data.copy()
        
        for filter_name, filter_instance in self.filters:
            if filter_instance.enabled:
                try:
                    result_data, filter_result = filter_instance.apply(result_data)
                    self.filter_results[filter_name] = filter_result
                    logger.info(f"筛选器 '{filter_name}' 执行完成，排除 {filter_result.get('excluded_count', 0)} 条记录")
                except Exception as e:
                    logger.error(f"筛选器 '{filter_name}' 执行失败: {e}")
                    self.filter_results[filter_name] = {
                        'status': 'error',
                        'error': str(e)
                    }
        
        return result_data
```

#### 3.3.5 具体筛选器实现

**题名关键词筛选器**
```python
class TitleKeywordsFilter(BaseFilter):
    """题名关键词筛选器"""
    
    def apply(self, data: pd.DataFrame) -> Tuple[pd.DataFrame, Dict[str, Any]]:
        """应用题名关键词筛选"""
        result_data = data.copy()
        valid_columns = self._validate_columns(data)
        
        if not valid_columns:
            return result_data, {
                'status': 'skipped',
                'reason': f'目标列 {self.target_columns} 不存在'
            }
        
        # 加载关键词文件
        patterns = self._load_patterns(self.config['file'])
        match_type = self.config['match_type']
        
        # 应用筛选
        excluded_mask = pd.Series(False, index=result_data.index)
        
        for pattern in patterns:
            excluded_mask |= self._match_pattern(
                result_data['题名'].astype(str), pattern, match_type
            )
        
        excluded_count = excluded_mask.sum()
        result_data = result_data[~excluded_mask]
        
        return result_data, {
            'description': self.description,
            'target_column': '题名',
            'match_type': match_type,
            'patterns_count': len(patterns),
            'excluded_count': excluded_count,
            'patterns_used': patterns[:5]
        }
```

**索书号/CLC筛选器（合并版本）**
```python
class CallNumberFilter(BaseFilter):
    """索书号和CLC号筛选器（合并版本）"""
    
    def apply(self, data: pd.DataFrame) -> Tuple[pd.DataFrame, Dict[str, Any]]:
        """应用索书号和CLC号筛选"""
        result_data = data.copy()
        valid_columns = self._validate_columns(data)
        
        if not valid_columns:
            return result_data, {
                'status': 'skipped',
                'reason': f'目标列 {self.target_columns} 不存在'
            }
        
        # 加载模式文件
        patterns = self._load_patterns(self.config['file'])
        match_type = self.config['match_type']
        
        # 对每个目标列应用筛选
        excluded_mask = pd.Series(False, index=result_data.index)
        
        for column in valid_columns:
            for pattern in patterns:
                excluded_mask |= self._match_pattern(
                    result_data[column].astype(str), pattern, match_type
                )
        
        excluded_count = excluded_mask.sum()
        result_data = result_data[~excluded_mask]
        
        return result_data, {
            'description': self.description,
            'target_columns': valid_columns,
            'match_type': match_type,
            'patterns_count': len(patterns),
            'excluded_count': excluded_count,
            'patterns_used': patterns[:5]
        }
```

**通用匹配算法**
```python
class MatchUtils:
    """通用匹配算法工具类"""
    
    @staticmethod
    def match_pattern(text: pd.Series, pattern: str, match_type: str) -> pd.Series:
        """统一匹配算法
        
        Args:
            text: 待匹配文本序列
            pattern: 匹配模式
            match_type: 匹配类型 (contains/starts_with/ends_with/regex)
        
        Returns:
            pd.Series: 匹配结果布尔序列
        """
        if match_type == "contains":
            return text.str.contains(pattern, na=False, case=False)
        elif match_type == "starts_with":
            return text.str.startswith(pattern, na=False)
        elif match_type == "ends_with":
            return text.str.endswith(pattern, na=False)
        elif match_type == "regex":
            import re
            return text.str.match(pattern, na=False)
        else:
            raise ValueError(f"不支持的匹配类型: {match_type}")
```

### 3.4 筛选流程设计

#### 3.4.1 筛选顺序
1. **数据预处理** - 验证数据完整性和格式
2. **规则A筛选** - 排除顶流热门图书
3. **规则B筛选** - 排除特定类型图书（题名关键词 + 索书号/CLC）
4. **规则C筛选** - Excel列值筛选
5. **结果合并** - 合并所有规则的结果
6. **质量检查** - 验证筛选结果的合理性

#### 3.4.2 新增筛选规则的扩展方式
```python
# 1. 创建新的筛选器类
class CustomFilter(BaseFilter):
    """自定义筛选器示例"""
    
    def apply(self, data: pd.DataFrame) -> Tuple[pd.DataFrame, Dict[str, Any]]:
        # 实现自定义筛选逻辑
        pass

# 2. 注册到筛选器注册表
FilterRegistry.register('custom', CustomFilter)

# 3. 在配置文件中添加新规则
custom_filter:
  enabled: true
  description: "自定义筛选规则"
  target_column: "自定义列"
  # ... 其他配置
```

### 3.5 集成方案

#### 3.5.1 主流程集成点
在 `main.py` 中添加：
```python
from src.core.data_filter import BookFilterFinal

# 在步骤6后添加筛选步骤
def process_monthly_return_data_with_filtering():
    # ... 前6步保持不变 ...
    
    # 新增步骤7: 降噪筛选
    logger.info("步骤7: 降噪筛选")
    filter_engine = BookFilterFinal()
    filtered_data = filter_engine.filter_books(final_data)
    
    # 步骤8: 筛选结果输出
    logger.info("步骤8: 筛选结果输出")
    filter_output_files = export_filtered_results(filtered_data)
    
    return filtered_data, filter_output_files
```

#### 3.5.2 输出文件设计
- `月归还数据筛选结果_{timestamp}.xlsx` - 筛选后的Excel数据
- `降噪筛选报告_{timestamp}.txt` - 筛选过程统计报告
- `筛选规则应用详情_{timestamp}.txt` - 每个规则的具体应用情况

### 3.6 改进的统计报告

#### 3.6.1 详细统计信息
```
书海回响 - 降噪筛选报告（最终版）
=====================================
生成时间: 2025-10-30 15:30:00
筛选前数据: 28,390条记录，26,641个唯一索书号
可用Excel列: [题名, 索书号, 附加信息, 备注, 类型/册数, 近四个月总次数]

配置验证结果:
✅ 规则A: 目标列 "近四个月总次数" - 存在
✅ 规则B: 2个筛选条件，2个目标列验证通过
✅ 规则C: 3个筛选条件，3个目标列验证通过

规则A - 排除顶流热门（前15%）:
  目标列: 近四个月总次数
  动态阈值: 借阅次数≥18次（基于当月数据自动计算）
  排除数量: 156条记录，142个唯一索书号
  覆盖率: 0.55%

规则B - 排除特定类型（整合版本）:
  ├─ 题名关键词 [列: 题名]: 排除1,234条记录（43个关键词）
  ├─ 索书号/CLC号 [列: 索书号, CLC号]: 排除890条记录（18个模式）
  └─ 小计: 排除2,124条记录

规则C - Excel列值筛选:
  ├─ 附加信息_9位数字格式 [列: 附加信息]: 排除123条记录
  ├─ 备注_排除关键词 [列: 备注]: 排除45条记录
  └─ 小计: 排除168条记录

总计筛选结果:
  原始数据: 28,390条记录
  最终数据: 25,942条记录
  总排除率: 8.62%
  剩余索书号: 24,785个

模块化设计优势:
  ✅ 支持动态新增筛选规则
  ✅ 原子化设计，便于维护
  ✅ 自动列名映射和验证
  ✅ 详细的错误处理和日志
```

## 4. 实施优先级
1. **高优先级**：基础筛选器架构和规则A实现
2. **中优先级**：规则B和C的整合实现
3. **低优先级**：高级统计报告和优化

## 5. 质量保证
- 提供筛选前的数据备份
- 支持筛选规则的灵活调整和新增
- 生成详细的筛选日志和统计报告
- 支持筛选结果的回溯和验证
- 自动化测试确保模块化设计的稳定性

## 6. 版本优势总结

### 6.1 整合优化
- **合并索书号和CLC**：统一处理，减少重复配置
- **简化题名关键词文件**：取消_contains和_starts的区别，使用match_type进行说明
- **明确的列名配置**：避免列名不匹配问题

### 6.2 模块化设计
- **原子化筛选器**：每个筛选规则独立实现
- **动态加载机制**：支持运行时新增筛选规则
- **统一的接口**：基于抽象类确保一致性

### 6.3 扩展性强
- **插件式架构**：新增筛选规则无需修改核心代码
- **配置驱动**：所有筛选条件通过配置文件控制
- **向后兼容**：支持平滑升级现有配置

### 6.4 健壮性好
- **自动列名映射**：处理常见的列名变体
- **错误容错机制**：单个筛选器失败不影响整体流程
- **详细的日志记录**：便于问题排查和优化

## 7. 使用示例

### 7.1 添加新的筛选规则
```python
# 1. 创建自定义筛选器
class ISBNFilter(BaseFilter):
    def apply(self, data: pd.DataFrame):
        # 实现ISBN号筛选逻辑
        pass

# 2. 注册筛选器
FilterRegistry.register('isbn', ISBNFilter)

# 3. 在配置文件中添加
filtering:
  rule_d:
    isbn_validation:
      enabled: true
      description: "ISBN号格式验证"
      target_column: "ISBN"
      filter_type: "regex"
      pattern: "^[0-9]{13}$"
```

### 7.2 运行时动态启用/禁用筛选规则
```python
# 禁用某个筛选规则
filter_engine.filters['title_keywords'].enabled = False

# 添加新的筛选规则
new_config = {
    'enabled': True,
    'description': '新筛选规则',
    'target_column': '新列名',
    # ... 其他配置
}
FilterRegistry.create_filter('column_value', new_config)
```

这个最终版本整合了v1-v4的所有优点，同时满足了您的具体要求，确保了代码的模块化、原子化和可扩展性。