# 历史数据查重数据库设计文档

## 概述

本文档描述了豆瓣评分模块中历史数据查重功能的数据库设计方案。该数据库用于存储历史借阅数据和豆瓣信息，并提供高效的查重功能。

## 设计背景

在执行ISBN爬取和豆瓣爬虫逻辑前，需要先使用书目条码去历史数据查重，以避免重复处理已存在的数据。历史数据包括三类信息：
1. **基础借阅数据**：书目基本信息（索书号、书名、书目条码等）
2. **借阅记录数据**：多次借阅的记录（读者卡号、提交时间、归还时间等）
3. **统计汇总数据**：每月统计的借阅次数

## 设计原则

- **数据分离**：将不变的基础信息和豆瓣信息，与变化的借阅记录和统计数据分离
- **唯一标识**：使用 `barcode`（书目条码）作为唯一标识符
- **时间序列**：支持借阅记录的历史追溯和统计数据的月度聚合
- **查重高效**：优化查重查询的性能
- **数据完整性**：通过外键约束保证数据一致性

## 数据库结构

### 表1：books（书籍基础信息和豆瓣信息）

**作用**：存储每本书的固定信息，一本书对应一条记录

**关系**：1对1关系（每本书一条记录）

```sql
CREATE TABLE IF NOT EXISTS books (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    barcode TEXT UNIQUE NOT NULL,  -- 书目条码（唯一键）

    -- ============ 书籍基础信息（不变）===========
    call_no TEXT NOT NULL,         -- 索书号
    book_title TEXT NOT NULL,      -- 书名
    additional_info TEXT,          -- 附加信息
    isbn TEXT,                     -- ISBN号

    -- ============ 豆瓣信息（1对1，不变）===========
    douban_url TEXT,               -- 豆瓣链接
    douban_rating REAL,            -- 豆瓣评分
    douban_title TEXT,             -- 豆瓣书名
    douban_subtitle TEXT,          -- 豆瓣副标题
    douban_original_title TEXT,    -- 豆瓣原作名
    douban_author TEXT,            -- 豆瓣作者
    douban_translator TEXT,        -- 豆瓣译者
    douban_publisher TEXT,         -- 豆瓣出版社
    douban_producer TEXT,          -- 豆瓣出品方
    douban_series TEXT,            -- 豆瓣丛书
    douban_series_link TEXT,       -- 豆瓣丛书链接
    douban_price TEXT,             -- 豆瓣定价
    douban_isbn TEXT,              -- 豆瓣ISBN
    douban_pages INTEGER,          -- 豆瓣页数
    douban_binding TEXT,           -- 豆瓣装帧
    douban_pub_year INTEGER,       -- 豆瓣出版年
    douban_rating_count INTEGER,   -- 豆瓣评价人数
    douban_summary TEXT,           -- 豆瓣内容简介
    douban_author_intro TEXT,      -- 豆瓣作者简介
    douban_catalog TEXT,           -- 豆瓣目录
    douban_cover_image TEXT,       -- 豆瓣封面图片链接

    -- ============ 元数据 ============
    data_version TEXT DEFAULT '1.0',
    created_at TEXT NOT NULL,
    updated_at TEXT,

    -- 索引
    INDEX idx_barcode (barcode),
    INDEX idx_isbn (isbn),
    INDEX idx_douban_isbn (douban_isbn),
    INDEX idx_book_title (book_title)
);
```

**关键字段说明**：
- `barcode`：书目条码，作为唯一键，用于查重
- `call_no, book_title, isbn`：书籍的基本信息
- 豆瓣相关字段：存储豆瓣爬取的信息，一本书对应一套豆瓣信息

---

### 表2：borrow_records（借阅记录）

**作用**：存储每本书的借阅历史记录

**关系**：1对多关系（一本书对应多条借阅记录）

```sql
CREATE TABLE IF NOT EXISTS borrow_records (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    barcode TEXT NOT NULL,  -- 外键，关联books表

    -- ============ 借阅记录信息 ============
    reader_card_no TEXT NOT NULL,  -- 读者卡号
    submit_time TEXT,              -- 提交时间
    return_time TEXT,              -- 归还时间
    storage_time TEXT,             -- 入库时间

    -- ============ 元数据 ============
    created_at TEXT NOT NULL,      -- 记录创建时间

    -- 外键和索引
    FOREIGN KEY (barcode) REFERENCES books(barcode) ON DELETE CASCADE,
    INDEX idx_barcode (barcode),
    INDEX idx_reader_card_no (reader_card_no),
    INDEX idx_return_time (return_time)
);
```

**关键字段说明**：
- `barcode`：外键，关联books表
- `reader_card_no`：读者标识，可用于分析读者行为
- `submit_time, return_time`：借阅和归还时间，用于计算借阅周期

---

### 表3：borrow_statistics（统计信息）

**作用**：存储每月统计的借阅次数汇总

**关系**：1对多关系（同一本书在每个统计周期一条记录）

```sql
CREATE TABLE IF NOT EXISTS borrow_statistics (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    barcode TEXT NOT NULL,  -- 外键，关联books表

    -- ============ 统计周期信息 ============
    stat_period TEXT NOT NULL,     -- 统计周期标识（如"2024-10"）
    stat_year INTEGER NOT NULL,    -- 统计年份
    stat_month INTEGER NOT NULL,   -- 统计月份（1-12）
    period_start TEXT,             -- 周期开始时间
    period_end TEXT,               -- 周期结束时间

    -- ============ 借阅次数统计 ============
    borrow_count_3m INTEGER,       -- 近三个月总次数
    borrow_count_m1 INTEGER,       -- 第一月借阅次数
    borrow_count_m2 INTEGER,       -- 第二月借阅次数
    borrow_count_m3 INTEGER,       -- 第三月借阅次数

    -- ============ 元数据 ============
    created_at TEXT NOT NULL,      -- 记录创建时间
    updated_at TEXT,               -- 记录更新时间

    -- 外键和索引
    FOREIGN KEY (barcode) REFERENCES books(barcode) ON DELETE CASCADE,
    INDEX idx_barcode (barcode),
    INDEX idx_period (stat_year, stat_month),
    INDEX idx_barcode_period (barcode, stat_year, stat_month),

    -- 确保同一本书在同一统计周期只有一条记录
    UNIQUE(barcode, stat_year, stat_month)
);
```

**关键字段说明**：
- `stat_period`：统计周期标识，格式如"2024-10"（年-月）
- `stat_year, stat_month`：便于范围查询
- 借阅次数字段：支持三个月移动窗口的统计
- `UNIQUE(barcode, stat_year, stat_month)`：防止重复统计

---

## 表关系图

```
books (1) ←─────→ borrow_records (∞)
   │
   └───→ borrow_statistics (∞)
        [按统计周期聚合]

说明：
- books 与 borrow_records：1对多
- books 与 borrow_statistics：1对多
- borrow_records：无直接关联，通过books.barcode间接关联
- borrow_statistics：按月度统计，UNIQUE(barcode, stat_year, stat_month)
```

## 数据流向

```
Excel数据
├─ 基础信息 → books表（1条/书）
│   ├─ 索书号、书名、书目条码、附加信息、ISBN
│   └─ 豆瓣信息（url、rating、title等）
│
├─ 借阅记录 → borrow_records表（多条/书）
│   ├─ 读者卡号
│   ├─ 提交时间
│   ├─ 归还时间
│   └─ 入库时间
│
└─ 统计信息 → borrow_statistics表（每月/书）
    ├─ 统计周期（年-月）
    ├─ 近三个月总次数
    └─ 三个月分别的次数

查重流程：
输入：Excel中的书目条码列表
查询：SELECT barcode FROM books WHERE barcode IN (...)
输出：重复条码列表、新条码列表
```

## 使用示例

### 1. 查重：检查书籍是否已存在

```python
def check_book_exists(barcode_list, db_path="books_history.db"):
    """检查书籍是否已存在于数据库中"""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    # 构建查询
    placeholders = ','.join('?' * len(barcode_list))
    query = f"SELECT barcode FROM books WHERE barcode IN ({placeholders})"
    cursor.execute(query, barcode_list)

    # 获取已存在的条码
    existing = {row[0] for row in cursor.fetchall()}

    # 分离重复和新数据
    duplicates = [b for b in barcode_list if b in existing]
    new_barcodes = [b for b in barcode_list if b not in existing]

    conn.close()
    return duplicates, new_barcodes

# 使用示例
all_barcodes = ['B001', 'B002', 'B003', 'B001', 'B004']
duplicates, new_barcodes = check_book_exists(all_barcodes)
print(f"重复条码: {duplicates}")
print(f"新条码: {new_barcodes}")
```

### 2. 获取完整书籍信息

```python
def get_complete_book_info(barcode, db_path="books_history.db"):
    """获取完整书籍信息（基础信息+借阅记录+统计）"""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    # 查询基础信息和豆瓣信息
    book_query = "SELECT * FROM books WHERE barcode = ?"
    cursor.execute(book_query, (barcode,))
    book_info = cursor.fetchone()

    # 查询借阅记录
    borrow_query = """
    SELECT * FROM borrow_records
    WHERE barcode = ?
    ORDER BY return_time DESC
    """
    cursor.execute(borrow_query, (barcode,))
    borrow_records = cursor.fetchall()

    # 查询统计信息（获取最新统计）
    stats_query = """
    SELECT * FROM borrow_statistics
    WHERE barcode = ?
    ORDER BY stat_year DESC, stat_month DESC
    LIMIT 1
    """
    cursor.execute(stats_query, (barcode,))
    latest_stats = cursor.fetchone()

    conn.close()
    return {
        'book_info': book_info,
        'borrow_records': borrow_records,
        'latest_statistics': latest_stats
    }

# 使用示例
book_info = get_complete_book_info('B001')
print(f"书名: {book_info['book_info'].book_title}")
print(f"豆瓣评分: {book_info['book_info'].douban_rating}")
print(f"借阅记录数: {len(book_info['borrow_records'])}")
print(f"最新统计: {book_info['latest_statistics']}")
```

### 3. 批量保存数据

```python
def save_batch_data(new_books, borrow_records_list, statistics_list,
                   db_path="books_history.db"):
    """批量保存数据到三张表"""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    current_time = datetime.now().isoformat()

    try:
        # 1. 保存books数据（基础信息+豆瓣信息）
        for book_data in new_books:
            query = """
            INSERT OR REPLACE INTO books (
                barcode, call_no, book_title, additional_info, isbn,
                douban_url, douban_rating, douban_title, douban_subtitle,
                douban_original_title, douban_author, douban_translator,
                douban_publisher, douban_producer, douban_series,
                douban_series_link, douban_price, douban_isbn, douban_pages,
                douban_binding, douban_pub_year, douban_rating_count,
                douban_summary, douban_author_intro, douban_catalog,
                douban_cover_image,
                created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """
            values = (
                book_data.get('barcode'),
                book_data.get('call_no'),
                book_data.get('book_title'),
                book_data.get('additional_info'),
                book_data.get('isbn'),
                book_data.get('douban_url'),
                book_data.get('douban_rating'),
                book_data.get('douban_title'),
                book_data.get('douban_subtitle'),
                book_data.get('douban_original_title'),
                book_data.get('douban_author'),
                book_data.get('douban_translator'),
                book_data.get('douban_publisher'),
                book_data.get('douban_producer'),
                book_data.get('douban_series'),
                book_data.get('douban_series_link'),
                book_data.get('douban_price'),
                book_data.get('douban_isbn'),
                book_data.get('douban_pages'),
                book_data.get('douban_binding'),
                book_data.get('douban_pub_year'),
                book_data.get('douban_rating_count'),
                book_data.get('douban_summary'),
                book_data.get('douban_author_intro'),
                book_data.get('douban_catalog'),
                book_data.get('douban_cover_image'),
                current_time,
                current_time
            )
            cursor.execute(query, values)

        # 2. 保存borrow_records数据（借阅记录）
        for record_data in borrow_records_list:
            query = """
            INSERT INTO borrow_records (
                barcode, reader_card_no, submit_time, return_time, storage_time
            ) VALUES (?, ?, ?, ?, ?)
            """
            values = (
                record_data.get('barcode'),
                record_data.get('reader_card_no'),
                record_data.get('submit_time'),
                record_data.get('return_time'),
                record_data.get('storage_time', current_time)
            )
            cursor.execute(query, values)

        # 3. 保存borrow_statistics数据（统计信息）
        for stat_data in statistics_list:
            query = """
            INSERT OR REPLACE INTO borrow_statistics (
                barcode, stat_period, stat_year, stat_month,
                period_start, period_end,
                borrow_count_3m, borrow_count_m1, borrow_count_m2, borrow_count_m3,
                created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """
            values = (
                stat_data.get('barcode'),
                stat_data.get('stat_period'),
                stat_data.get('stat_year'),
                stat_data.get('stat_month'),
                stat_data.get('period_start'),
                stat_data.get('period_end'),
                stat_data.get('borrow_count_3m'),
                stat_data.get('borrow_count_m1'),
                stat_data.get('borrow_count_m2'),
                stat_data.get('borrow_count_m3'),
                current_time,
                current_time
            )
            cursor.execute(query, values)

        conn.commit()
        print("✅ 数据保存成功")

    except Exception as e:
        conn.rollback()
        print(f"❌ 保存失败: {e}")
        raise
    finally:
        conn.close()

# 使用示例
new_books = [
    {'barcode': 'B005', 'call_no': 'TP311.5', 'book_title': 'Python编程',
     'isbn': '9787115428028', 'douban_rating': 9.0}
]

borrow_records_list = [
    {'barcode': 'B005', 'reader_card_no': 'R001', 'submit_time': '2024-10-01',
     'return_time': '2024-10-15'}
]

statistics_list = [
    {'barcode': 'B005', 'stat_period': '2024-10', 'stat_year': 2024, 'stat_month': 10,
     'borrow_count_3m': 5, 'borrow_count_m1': 2, 'borrow_count_m2': 2, 'borrow_count_m3': 1}
]

save_batch_data(new_books, borrow_records_list, statistics_list)
```

### 4. 获取借阅趋势分析

```python
def get_borrowing_trend(barcode, months=12, db_path="books_history.db"):
    """获取某本书的借阅趋势分析"""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    # 获取近N个月的统计信息
    query = """
    SELECT stat_year, stat_month, borrow_count_3m, borrow_count_m1, borrow_count_m2, borrow_count_m3
    FROM borrow_statistics
    WHERE barcode = ?
    ORDER BY stat_year DESC, stat_month DESC
    LIMIT ?
    """
    cursor.execute(query, (barcode, months))
    stats = cursor.fetchall()

    # 分析趋势
    trend = []
    for stat in stats:
        trend.append({
            'period': f"{stat[0]}-{stat[1]:02d}",
            'total_3m': stat[2],
            'monthly': [stat[3], stat[4], stat[5]]
        })

    conn.close()
    return trend

# 使用示例
trend = get_borrowing_trend('B001', months=6)
for t in trend:
    print(f"{t['period']}: 3个月总量={t['total_3m']}, 月度分布={t['monthly']}")
```

## 性能优化建议

### 1. 索引优化

- `books.barcode`：查重的主要查询字段，**必加索引**
- `borrow_records.barcode`：按条码查询借阅记录
- `borrow_statistics.barcode, stat_year, stat_month`：复合索引，支持按条码和时间查询

### 2. 查询优化

- 查重时使用 `IN` 子句批量查询，避免循环单条查询
- 使用 `LIMIT` 限制查询结果数量
- 对大数据量场景，考虑分页查询

### 3. 写入优化

- 使用事务批量提交，减少数据库I/O
- `INSERT OR REPLACE` 保证幂等性
- 定期清理过期的历史数据（可选）

## 数据完整性保证

### 外键约束

```sql
FOREIGN KEY (barcode) REFERENCES books(barcode) ON DELETE CASCADE
```

当删除books表中的记录时，自动删除相关的借阅记录和统计信息。

### 唯一性约束

```sql
UNIQUE(barcode)  -- books表
UNIQUE(barcode, stat_year, stat_month)  -- borrow_statistics表
```

保证数据不重复。

## 版本信息

- **版本**：1.0
- **创建时间**：2025-11-04
- **最后更新**：2025-11-04
- **作者**：豆瓣评分模块开发组

## 参考资料

- [SQLite Foreign Key Documentation](https://www.sqlite.org/foreignkeys.html)
- [SQLite Index Documentation](https://www.sqlite.org/queryplanner-ng.html#searching)
- [项目总体设计文档](项目说明.md)
