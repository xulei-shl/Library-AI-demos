# æ•°æ®åº“æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ - æ”¯æŒ10Wçº§æ•°æ®

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**åˆ›å»ºæ—¶é—´**: 2025-11-20  
**å½±å“æ¨¡å—**: `src/core/douban/database`  
**ä¼˜åŒ–ç›®æ ‡**: æ”¯æŒ10Wçº§åˆ«æ•°æ®çš„é«˜æ•ˆå¤„ç†

---

## ğŸ“‹ ç›®å½•

1. [æ€§èƒ½åˆ†ææ€»ç»“](#æ€§èƒ½åˆ†ææ€»ç»“)
2. [æ ¸å¿ƒé—®é¢˜è¯†åˆ«](#æ ¸å¿ƒé—®é¢˜è¯†åˆ«)
3. [ä¼˜åŒ–æ–¹æ¡ˆè¯¦è§£](#ä¼˜åŒ–æ–¹æ¡ˆè¯¦è§£)
4. [æ€§èƒ½å¯¹æ¯”é¢„æµ‹](#æ€§èƒ½å¯¹æ¯”é¢„æµ‹)
5. [å®æ–½è®¡åˆ’](#å®æ–½è®¡åˆ’)
6. [é£é™©è¯„ä¼°](#é£é™©è¯„ä¼°)

---

## æ€§èƒ½åˆ†ææ€»ç»“

### å½“å‰æ¶æ„åˆ†æ

#### 1. æ•°æ®åº“æŸ¥é‡é€»è¾‘ (`DatabaseManager.batch_check_duplicates`)

**å®ç°æ–¹å¼**:
```python
# å•æ¬¡æ‰¹é‡SQLæŸ¥è¯¢
placeholders = ','.join(['?' for _ in barcodes])
sql = f"SELECT * FROM books WHERE barcode IN ({placeholders})"
cursor = self.conn.execute(sql, barcodes)
```

**æ€§èƒ½ç‰¹ç‚¹**:
- âœ… ä½¿ç”¨æ‰¹é‡æŸ¥è¯¢,åˆ©ç”¨barcodeçš„UNIQUEç´¢å¼•
- âœ… æ—¶é—´å¤æ‚åº¦: O(n)
- âœ… 2Kæ•°æ®: æ¯«ç§’çº§å“åº”

**å­˜åœ¨é—®é¢˜**:
- âš ï¸ **SQLiteå‚æ•°é™åˆ¶**: é»˜è®¤æœ€å¤§999ä¸ªå‚æ•°
- âš ï¸ **10Wæ•°æ®**: éœ€è¦åˆ†æ‰¹æŸ¥è¯¢,å¦åˆ™SQLæ‰§è¡Œå¤±è´¥

---

#### 2. æ•°æ®å†™å›Excelé€»è¾‘ (`ExcelUpdater`)

**å®ç°æ–¹å¼**:
```python
def _find_row_index(self, barcode: str) -> int:
    for idx, row in self.df.iterrows():  # éå†æ‰€æœ‰è¡Œ
        row_barcode = str(row[barcode_column]).strip()
        if row_barcode == str(barcode).strip():
            return idx
    return -1

def update_from_database(self, books_data: List[Dict]):
    for book_data in books_data:  # mæ¬¡å¾ªç¯
        excel_index = self._find_row_index(barcode)  # O(n)æŸ¥æ‰¾
        self._update_douban_fields(self.df, excel_index, book_data)
```

**æ€§èƒ½ç‰¹ç‚¹**:
- âŒ **è‡´å‘½ç“¶é¢ˆ**: åµŒå¥—å¾ªç¯å¯¼è‡´O(mÃ—n)å¤æ‚åº¦
- âŒ **2Kæ•°æ®**: æ•°ç§’çº§ (å°šå¯æ¥å—)
- âŒ **10Wæ•°æ®**: é¢„è®¡æ•°å°æ—¶ (å®Œå…¨ä¸å¯ç”¨)

**æ€§èƒ½è®¡ç®—**:
```
å‡è®¾: æ›´æ–°10,000æ¡è®°å½•,Excelæ€»è¡Œæ•°100,000
æ€»æ¯”è¾ƒæ¬¡æ•°: 10,000 Ã— 100,000 = 10äº¿æ¬¡
é¢„è®¡è€—æ—¶: 2-4å°æ—¶ (åŸºäºpandas iterrowsæ€§èƒ½)
```

---

#### 3. Excelæ•°æ®æ›´æ–°å›DBé€»è¾‘ (`DatabaseManager._batch_save_books`)

**å®ç°æ–¹å¼**:
```python
for book_data in batch:
    # æŸ¥è¯¢1: æ£€æŸ¥è®°å½•æ˜¯å¦å­˜åœ¨
    existing_book = self.get_book_by_barcode(barcode)
    
    # æŸ¥è¯¢2: è·å–å¹¶é€’å¢ç‰ˆæœ¬å·
    book_data['data_version'] = self._increment_data_version(barcode)
    
    # æ‰§è¡ŒUPSERT
    self.conn.execute(sql, values)
```

**æ€§èƒ½ç‰¹ç‚¹**:
- âš ï¸ **N+1æŸ¥è¯¢é—®é¢˜**: æ¯æ¡è®°å½•2æ¬¡é¢å¤–SELECT
- âœ… ä½¿ç”¨äº‹åŠ¡æ‰¹é‡æäº¤
- âœ… UPSERTè¯­å¥é«˜æ•ˆ

**æ€§èƒ½è®¡ç®—**:
```
100,000æ¡æ•°æ® = 200,000æ¬¡SELECTæŸ¥è¯¢
é¢„è®¡è€—æ—¶: 10-30åˆ†é’Ÿ (å–å†³äºç£ç›˜IO)
```

---

## æ ¸å¿ƒé—®é¢˜è¯†åˆ«

### é—®é¢˜1: Excelæ›´æ–° - O(mÃ—n)å¤æ‚åº¦ ğŸ”´ ä¸¥é‡

**é—®é¢˜ä»£ç ** (`excel_updater.py:187-213`):
```python
def _find_row_index(self, barcode: str) -> int:
    for idx, row in self.df.iterrows():  # æ¯æ¬¡éƒ½éå†æ•´ä¸ªDataFrame
        row_barcode = str(row[barcode_column]).strip()
        if row_barcode == str(barcode).strip():
            return idx
    return -1
```

**å½±å“**:
- 10Wæ•°æ®åœºæ™¯ä¸‹,è¿™æ˜¯**æœ€ä¸¥é‡çš„æ€§èƒ½ç“¶é¢ˆ**
- å¯¼è‡´æ•´ä½“å¤„ç†æ—¶é—´ä»åˆ†é’Ÿçº§å»¶é•¿åˆ°å°æ—¶çº§

**æ ¹æœ¬åŸå› **:
- æœªå»ºç«‹barcodeåˆ°è¡Œç´¢å¼•çš„æ˜ å°„
- æ¯æ¬¡æŸ¥æ‰¾éƒ½çº¿æ€§æ‰«ææ•´ä¸ªDataFrame

---

### é—®é¢˜2: æ•°æ®åº“å†™å…¥ - N+1æŸ¥è¯¢ ğŸŸ¡ ä¸­ç­‰

**é—®é¢˜ä»£ç ** (`database_manager.py:407-414`):
```python
existing_book = None
if 'barcode' in book_data:
    barcode = book_data['barcode']
    existing_book = self.get_book_by_barcode(barcode)  # æŸ¥è¯¢1
    book_data['data_version'] = self._increment_data_version(barcode)  # æŸ¥è¯¢2
```

**å½±å“**:
- 10Wæ•°æ® = 20Wæ¬¡é¢å¤–æŸ¥è¯¢
- å¢åŠ 10-30åˆ†é’Ÿå¤„ç†æ—¶é—´

**æ ¹æœ¬åŸå› **:
- é€æ¡æŸ¥è¯¢è€Œéæ‰¹é‡æŸ¥è¯¢
- ç‰ˆæœ¬å·é€’å¢é€»è¾‘ä¾èµ–é¢å¤–æŸ¥è¯¢

---

### é—®é¢˜3: SQLå‚æ•°é™åˆ¶ ğŸŸ¡ ä¸­ç­‰

**é—®é¢˜ä»£ç ** (`database_manager.py:243-250`):
```python
placeholders = ','.join(['?' for _ in barcodes])  # å¯èƒ½è¶…è¿‡999ä¸ª
sql = f"SELECT * FROM books WHERE barcode IN ({placeholders})"
cursor = self.conn.execute(sql, barcodes)  # SQLiteé™åˆ¶999ä¸ªå‚æ•°
```

**å½±å“**:
- 10Wæ¡barcodeä¼šå¯¼è‡´SQLæ‰§è¡Œå¤±è´¥
- éœ€è¦åˆ†æ‰¹å¤„ç†

---

## ä¼˜åŒ–æ–¹æ¡ˆè¯¦è§£

### æ–¹æ¡ˆ1: Excelæ›´æ–°ä¼˜åŒ– - ç´¢å¼•æ˜ å°„ ğŸ¯ ä¼˜å…ˆçº§æœ€é«˜

#### ä¼˜åŒ–æ€è·¯
å°†O(mÃ—n)å¤æ‚åº¦é™è‡³O(m+n):
1. **ä¸€æ¬¡æ€§æ„å»ºç´¢å¼•**: éå†DataFrameæ„å»ºbarcodeâ†’indexæ˜ å°„ (O(n))
2. **O(1)æŸ¥æ‰¾**: ä½¿ç”¨å­—å…¸ç›´æ¥æŸ¥æ‰¾è¡Œç´¢å¼• (O(1))
3. **æ‰¹é‡æ›´æ–°**: éå†å¾…æ›´æ–°æ•°æ®å¹¶æ›´æ–° (O(m))

#### ä¼˜åŒ–ä»£ç 

**æ–°å¢æ–¹æ³•** (`excel_updater.py`):
```python
def _build_barcode_index(self) -> Dict[str, int]:
    """
    æ„å»ºbarcodeåˆ°è¡Œç´¢å¼•çš„æ˜ å°„
    
    Returns:
        Dict[str, int]: barcode â†’ DataFrameè¡Œç´¢å¼•çš„æ˜ å°„
    """
    barcode_column = None
    if 'barcode' in self.df.columns:
        barcode_column = 'barcode'
    elif 'ä¹¦ç›®æ¡ç ' in self.df.columns:
        barcode_column = 'ä¹¦ç›®æ¡ç '
    else:
        raise ValueError("Excelä¸­æœªæ‰¾åˆ°barcodeåˆ—")
    
    # æ„å»ºæ˜ å°„: O(n)å¤æ‚åº¦,ä½†åªæ‰§è¡Œä¸€æ¬¡
    barcode_to_idx = {}
    for idx, row in self.df.iterrows():
        barcode = str(row[barcode_column]).strip()
        if barcode:
            barcode_to_idx[barcode] = idx
    
    logger.debug(f"æ„å»ºbarcodeç´¢å¼•å®Œæˆ: {len(barcode_to_idx)} æ¡è®°å½•")
    return barcode_to_idx
```

**ä¿®æ”¹æ–¹æ³•** (`excel_updater.py:99-141`):
```python
def update_from_database(self, books_data: List[Dict]):
    """
    ä»æ•°æ®åº“æ›´æ–°æ•°æ®åˆ°Excel (ä¼˜åŒ–ç‰ˆ)
    
    Args:
        books_data: ä»æ•°æ®åº“è·å–çš„ä¹¦ç±æ•°æ®åˆ—è¡¨
    """
    if self.df is None or len(self.df) == 0:
        logger.warning("Excelæ•°æ®ä¸ºç©º,è·³è¿‡æ›´æ–°")
        return
    
    if not books_data:
        logger.info("æ²¡æœ‰æ•°æ®åº“æ•°æ®éœ€è¦æ›´æ–°")
        return
    
    logger.info(f"å¼€å§‹ä»æ•°æ®åº“æ›´æ–° {len(books_data)} æ¡è®°å½•åˆ°Excel")
    
    try:
        # ä¼˜åŒ–: ä¸€æ¬¡æ€§æ„å»ºbarcodeç´¢å¼• O(n)
        barcode_to_idx = self._build_barcode_index()
        
        updated_count = 0
        not_found_count = 0
        
        # ä¼˜åŒ–: ç›´æ¥æŸ¥æ‰¾æ›´æ–° O(m)
        for book_data in books_data:
            barcode = book_data.get('barcode') or book_data.get('ä¹¦ç›®æ¡ç ')
            if not barcode:
                logger.warning("è·³è¿‡æ²¡æœ‰barcodeçš„è®°å½•")
                continue
            
            barcode = str(barcode).strip()
            
            # O(1)æŸ¥æ‰¾
            if barcode in barcode_to_idx:
                excel_index = barcode_to_idx[barcode]
                fields_updated = self._update_douban_fields(
                    self.df, excel_index, book_data
                )
                
                if fields_updated > 0:
                    updated_count += 1
            else:
                not_found_count += 1
                logger.debug(f"åœ¨Excelä¸­æœªæ‰¾åˆ°æ¡ç  {barcode}")
        
        logger.info(
            f"ä»æ•°æ®åº“æ›´æ–°å®Œæˆ: {updated_count} æ¡æˆåŠŸ, "
            f"{not_found_count} æ¡æœªæ‰¾åˆ°"
        )
    
    except Exception as e:
        logger.error(f"ä»æ•°æ®åº“æ›´æ–°Excelå¤±è´¥: {e}")
        raise
```

**åŒæ ·ä¿®æ”¹** (`excel_updater.py:143-185`):
```python
def update_from_crawler(self, books_data: List[Dict]):
    """
    ä»çˆ¬è™«æ›´æ–°æ•°æ®åˆ°Excel (ä¼˜åŒ–ç‰ˆ)
    
    Args:
        books_data: çˆ¬è™«è·å–çš„ä¹¦ç±æ•°æ®åˆ—è¡¨
    """
    if self.df is None or len(self.df) == 0:
        logger.warning("Excelæ•°æ®ä¸ºç©º,è·³è¿‡æ›´æ–°")
        return
    
    if not books_data:
        logger.info("æ²¡æœ‰çˆ¬è™«æ•°æ®éœ€è¦æ›´æ–°")
        return
    
    logger.info(f"å¼€å§‹ä»çˆ¬è™«æ›´æ–° {len(books_data)} æ¡è®°å½•åˆ°Excel")
    
    try:
        # ä¼˜åŒ–: ä¸€æ¬¡æ€§æ„å»ºbarcodeç´¢å¼•
        barcode_to_idx = self._build_barcode_index()
        
        updated_count = 0
        not_found_count = 0
        
        for book_data in books_data:
            barcode = book_data.get('barcode') or book_data.get('ä¹¦ç›®æ¡ç ')
            if not barcode:
                logger.warning("è·³è¿‡æ²¡æœ‰barcodeçš„è®°å½•")
                continue
            
            barcode = str(barcode).strip()
            
            # O(1)æŸ¥æ‰¾
            if barcode in barcode_to_idx:
                excel_index = barcode_to_idx[barcode]
                fields_updated = self._update_douban_fields(
                    self.df, excel_index, book_data
                )
                
                if fields_updated > 0:
                    updated_count += 1
            else:
                not_found_count += 1
                logger.debug(f"åœ¨Excelä¸­æœªæ‰¾åˆ°æ¡ç  {barcode}")
        
        logger.info(
            f"ä»çˆ¬è™«æ›´æ–°å®Œæˆ: {updated_count} æ¡æˆåŠŸ, "
            f"{not_found_count} æ¡æœªæ‰¾åˆ°"
        )
    
    except Exception as e:
        logger.error(f"ä»çˆ¬è™«æ›´æ–°Excelå¤±è´¥: {e}")
        raise
```

**åºŸå¼ƒæ–¹æ³•**:
- `_find_row_index()` - ä¸å†éœ€è¦,å¯æ ‡è®°ä¸ºdeprecated

#### æ€§èƒ½æå‡
```
ä¼˜åŒ–å‰: O(mÃ—n) = 10,000 Ã— 100,000 = 10äº¿æ¬¡æ“ä½œ
ä¼˜åŒ–å: O(m+n) = 10,000 + 100,000 = 11ä¸‡æ¬¡æ“ä½œ
æå‡å€æ•°: ~10,000å€
è€—æ—¶: ä»2-4å°æ—¶é™è‡³ 5-10ç§’
```

---

### æ–¹æ¡ˆ2: æ•°æ®åº“å†™å…¥ä¼˜åŒ– - æ‰¹é‡é¢„æŸ¥è¯¢ ğŸ¯ ä¼˜å…ˆçº§é«˜

#### ä¼˜åŒ–æ€è·¯
1. **æ‰¹é‡æŸ¥è¯¢**: ä¸€æ¬¡æ€§æŸ¥è¯¢æ‰€æœ‰éœ€è¦çš„barcodeä¿¡æ¯
2. **å†…å­˜å¤„ç†**: åœ¨å†…å­˜ä¸­å®Œæˆç‰ˆæœ¬å·é€’å¢
3. **å‡å°‘æŸ¥è¯¢**: ä»2næ¬¡æŸ¥è¯¢é™è‡³1æ¬¡æ‰¹é‡æŸ¥è¯¢

#### ä¼˜åŒ–ä»£ç 

**æ–°å¢æ–¹æ³•** (`database_manager.py`):
```python
def batch_get_books_by_barcodes(self, barcodes: List[str]) -> Dict[str, Dict]:
    """
    æ‰¹é‡æŸ¥è¯¢ä¹¦ç±ä¿¡æ¯
    
    Args:
        barcodes: æ¡ç åˆ—è¡¨
    
    Returns:
        Dict[str, Dict]: barcode â†’ ä¹¦ç±ä¿¡æ¯çš„æ˜ å°„
    """
    if not barcodes:
        return {}
    
    try:
        # å¤„ç†SQLiteå‚æ•°é™åˆ¶
        BATCH_SIZE = 999
        all_books = {}
        
        for i in range(0, len(barcodes), BATCH_SIZE):
            batch = barcodes[i:i+BATCH_SIZE]
            placeholders = ','.join(['?' for _ in batch])
            sql = f"SELECT * FROM books WHERE barcode IN ({placeholders})"
            
            cursor = self.conn.execute(sql, batch)
            rows = cursor.fetchall()
            
            for row in rows:
                book_dict = dict(row)
                all_books[book_dict['barcode']] = book_dict
        
        logger.debug(f"æ‰¹é‡æŸ¥è¯¢å®Œæˆ: {len(all_books)}/{len(barcodes)} æ¡è®°å½•")
        return all_books
    
    except Exception as e:
        logger.error(f"æ‰¹é‡æŸ¥è¯¢ä¹¦ç±ä¿¡æ¯å¤±è´¥: {e}")
        return {}

def _increment_version_in_memory(self, current_version: str) -> str:
    """
    åœ¨å†…å­˜ä¸­é€’å¢ç‰ˆæœ¬å· (æ— éœ€æ•°æ®åº“æŸ¥è¯¢)
    
    Args:
        current_version: å½“å‰ç‰ˆæœ¬å·
    
    Returns:
        str: é€’å¢åçš„ç‰ˆæœ¬å·
    """
    try:
        version_num = float(current_version)
        new_version_num = round(version_num + 0.1, 1)
        return f"{new_version_num:.1f}"
    except (ValueError, TypeError):
        logger.warning(f"æ— æ³•è§£æç‰ˆæœ¬å· {current_version},ä½¿ç”¨é»˜è®¤ç‰ˆæœ¬")
        return '1.0'
```

**ä¿®æ”¹æ–¹æ³•** (`database_manager.py:391-489`):
```python
def _batch_save_books(self, books_data: List[Dict], batch_size: int, update_mode: str = "merge"):
    """
    æ‰¹é‡ä¿å­˜booksæ•°æ® (ä¼˜åŒ–ç‰ˆ)
    
    Args:
        books_data: booksè¡¨æ•°æ®åˆ—è¡¨
        batch_size: æ‰¹é‡å†™å…¥å¤§å°
        update_mode: æ›´æ–°æ¨¡å¼ (mergeä¿ç•™åŸå­—æ®µ,overwriteå®Œå…¨è¦†ç›–)
    """
    if not books_data:
        return
    
    # ä¼˜åŒ–: æ‰¹é‡é¢„æŸ¥è¯¢æ‰€æœ‰barcode
    all_barcodes = [b['barcode'] for b in books_data if 'barcode' in b]
    existing_books_map = self.batch_get_books_by_barcodes(all_barcodes)
    
    logger.debug(f"é¢„æŸ¥è¯¢å®Œæˆ: {len(existing_books_map)} æ¡å·²å­˜åœ¨è®°å½•")
    
    for i in range(0, len(books_data), batch_size):
        batch = books_data[i:i + batch_size]
        
        for book_data in batch:
            # ç¡®ä¿å¿…è¦å­—æ®µå­˜åœ¨
            book_data.setdefault('updated_at', datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
            
            # ä¼˜åŒ–: ä»å†…å­˜æ˜ å°„ä¸­è·å–ç°æœ‰è®°å½• (æ— éœ€æŸ¥è¯¢)
            existing_book = None
            if 'barcode' in book_data:
                barcode = book_data['barcode']
                existing_book = existing_books_map.get(barcode)
                
                # ä¼˜åŒ–: åœ¨å†…å­˜ä¸­å¤„ç†ç‰ˆæœ¬å· (æ— éœ€æŸ¥è¯¢)
                if existing_book:
                    current_version = existing_book.get('data_version', '1.0')
                    book_data['data_version'] = self._increment_version_in_memory(current_version)
                else:
                    book_data['data_version'] = '1.0'
            else:
                book_data.setdefault('data_version', '1.0')
            
            # ä¿ç•™åŸæœ‰created_at
            if existing_book and existing_book.get('created_at'):
                book_data['created_at'] = existing_book['created_at']
            else:
                book_data.setdefault('created_at', datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
            
            # æ ¹æ®æ›´æ–°æ¨¡å¼æ„å»ºUPSERTè¯­å¥ (é€»è¾‘ä¸å˜)
            if update_mode == "overwrite" or not existing_book:
                # å®Œå…¨è¦†ç›–æ¨¡å¼
                placeholders = ','.join(['?' for _ in book_data.keys()])
                columns = ','.join(book_data.keys())
                
                set_clauses = []
                for key in book_data.keys():
                    if key != 'barcode':
                        set_clauses.append(f"{key} = excluded.{key}")
                
                sql = f"""
                    INSERT INTO books ({columns})
                    VALUES ({placeholders})
                    ON CONFLICT(barcode) DO UPDATE SET
                        {', '.join(set_clauses)}
                    WHERE books.barcode = excluded.barcode
                """
                self.conn.execute(sql, list(book_data.values()))
            else:
                # åˆå¹¶æ¨¡å¼
                insert_columns = ['barcode']
                insert_values = [book_data['barcode']]
                set_clauses = []
                
                for key, value in book_data.items():
                    if key == 'barcode':
                        continue
                    
                    if value is not None and str(value).strip() != "":
                        insert_columns.append(key)
                        insert_values.append(value)
                        set_clauses.append(f"{key} = excluded.{key}")
                
                set_clauses.append("updated_at = excluded.updated_at")
                set_clauses.append("data_version = excluded.data_version")
                
                placeholders = ','.join(['?' for _ in insert_columns])
                columns = ','.join(insert_columns)
                
                sql = f"""
                    INSERT INTO books ({columns})
                    VALUES ({placeholders})
                    ON CONFLICT(barcode) DO UPDATE SET
                        {', '.join(set_clauses)}
                    WHERE books.barcode = excluded.barcode
                """
                self.conn.execute(sql, insert_values)
        
        logger.debug(f"å·²ä¿å­˜booksæ‰¹æ¬¡ {i // batch_size + 1}/{(len(books_data) - 1) // batch_size + 1} ({update_mode}æ¨¡å¼)")
```

**åºŸå¼ƒæ–¹æ³•**:
- `_increment_data_version()` - æ›¿æ¢ä¸º `_increment_version_in_memory()`

#### æ€§èƒ½æå‡
```
ä¼˜åŒ–å‰: 100,000æ¡ Ã— 2æ¬¡æŸ¥è¯¢ = 200,000æ¬¡SELECT
ä¼˜åŒ–å: 1æ¬¡æ‰¹é‡æŸ¥è¯¢ (åˆ†æ‰¹å¤„ç†,æ¯æ‰¹999æ¡)
æŸ¥è¯¢æ¬¡æ•°: ä»200,000æ¬¡é™è‡³ ~101æ¬¡
è€—æ—¶: ä»10-30åˆ†é’Ÿé™è‡³ 1-2åˆ†é’Ÿ
```

---

### æ–¹æ¡ˆ3: SQLå‚æ•°é™åˆ¶å¤„ç† ğŸ¯ ä¼˜å…ˆçº§ä¸­

#### ä¼˜åŒ–æ€è·¯
åœ¨æ‰¹é‡æŸ¥è¯¢æ—¶è‡ªåŠ¨åˆ†æ‰¹,é¿å…è¶…è¿‡SQLiteçš„999å‚æ•°é™åˆ¶

#### ä¼˜åŒ–ä»£ç 

**ä¿®æ”¹æ–¹æ³•** (`database_manager.py:219-315`):
```python
def batch_check_duplicates(self, barcodes: List[str], stale_days: int = 30) -> Dict:
    """
    æ‰¹é‡æŸ¥é‡,è¿”å›åˆ†ç±»ç»“æœ (ä¼˜åŒ–ç‰ˆ - æ”¯æŒå¤§æ‰¹é‡)
    
    Args:
        barcodes: æ¡ç åˆ—è¡¨
        stale_days: è¿‡æœŸå¤©æ•° (è¶…è¿‡è¯¥å¤©æ•°çš„æ•°æ®éœ€è¦é‡æ–°çˆ¬å–)
    
    Returns:
        Dict: åˆ†ç±»ç»“æœ
        {
            'existing_valid': [{'barcode': 'B001', 'data': book_data}, ...],
            'existing_stale': [{'barcode': 'B002', 'data': book_data}, ...],
            'new': ['B003', 'B004', ...]
        }
    """
    try:
        # ä¼˜åŒ–: å¤„ç†SQLiteå‚æ•°é™åˆ¶,åˆ†æ‰¹æŸ¥è¯¢
        BATCH_SIZE = 999
        all_existing_books = []
        
        for i in range(0, len(barcodes), BATCH_SIZE):
            batch = barcodes[i:i+BATCH_SIZE]
            placeholders = ','.join(['?' for _ in batch])
            sql = f"""
                SELECT * FROM books
                WHERE barcode IN ({placeholders})
                ORDER BY created_at DESC
            """
            
            cursor = self.conn.execute(sql, batch)
            batch_books = cursor.fetchall()
            all_existing_books.extend(batch_books)
            
            logger.debug(f"æŸ¥é‡æ‰¹æ¬¡ {i//BATCH_SIZE + 1}: æŸ¥è¯¢ {len(batch)} æ¡,æ‰¾åˆ° {len(batch_books)} æ¡")
        
        # è½¬æ¢ä¸ºå­—å…¸ä»¥ä¾¿å¿«é€ŸæŸ¥æ‰¾
        existing_dict = {book['barcode']: dict(book) for book in all_existing_books}
        
        # åˆ†ç±»ç»“æœ
        result = {
            'existing_valid': [],
            'existing_stale': [],
            'new': []
        }
        
        # è®¡ç®—è¿‡æœŸæ—¶é—´
        stale_threshold = (datetime.now() - timedelta(days=stale_days)).strftime('%Y-%m-%d %H:%M:%S')
        
        for barcode in barcodes:
            if barcode in existing_dict:
                book_data = existing_dict[barcode]
                created_at = book_data.get('created_at', '')
                douban_url = book_data.get('douban_url')
                
                needs_update = False
                
                # æ£€æŸ¥è±†ç“£URLæ˜¯å¦å­˜åœ¨
                if not douban_url or douban_url.strip() == '':
                    logger.debug(f"æ¡ç  {barcode}: douban_urlä¸ºç©º,éœ€è¦é‡æ–°çˆ¬å–")
                    needs_update = True
                # æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
                elif created_at > stale_threshold:
                    needs_update = False
                else:
                    logger.debug(f"æ¡ç  {barcode}: æ•°æ®å·²è¿‡æœŸ({stale_days}å¤©),éœ€è¦é‡æ–°çˆ¬å–")
                    needs_update = True
                
                if needs_update:
                    result['existing_stale'].append({
                        'barcode': barcode,
                        'data': book_data
                    })
                else:
                    result['existing_valid'].append({
                        'barcode': barcode,
                        'data': book_data
                    })
            else:
                result['new'].append(barcode)
        
        logger.info(
            f"æŸ¥é‡å®Œæˆ: {len(result['existing_valid'])}æ¡æœ‰æ•ˆ, "
            f"{len(result['existing_stale'])}æ¡éœ€çˆ¬å–, "
            f"{len(result['new'])}æ¡æ–°æ•°æ®"
        )
        
        return result
    
    except Exception as e:
        logger.error(f"æ‰¹é‡æŸ¥é‡å¤±è´¥: {e}")
        raise
```

#### æ€§èƒ½æå‡
```
ä¼˜åŒ–å‰: 100,000æ¡barcode â†’ SQLæ‰§è¡Œå¤±è´¥
ä¼˜åŒ–å: è‡ªåŠ¨åˆ†æ‰¹ (æ¯æ‰¹999æ¡) â†’ 101æ¬¡æŸ¥è¯¢
è€—æ—¶: ä»å¤±è´¥åˆ° 2-5ç§’
```

---

## æ€§èƒ½å¯¹æ¯”é¢„æµ‹

### æµ‹è¯•åœºæ™¯
- **Excelæ€»è¡Œæ•°**: 100,000
- **éœ€è¦æ›´æ–°çš„è®°å½•æ•°**: 10,000
- **æ•°æ®åº“ç°æœ‰è®°å½•**: 50,000

### æ€§èƒ½å¯¹æ¯”è¡¨

| æ“ä½œ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æå‡å€æ•° |
|------|--------|--------|----------|
| **æ•°æ®åº“æŸ¥é‡** | å¤±è´¥ (å‚æ•°è¶…é™) | 2-5ç§’ | N/A |
| **Excelæ›´æ–° (ä»DB)** | 2-4å°æ—¶ | **5-10ç§’** | **~1000x** |
| **Excelæ›´æ–° (ä»çˆ¬è™«)** | 2-4å°æ—¶ | **5-10ç§’** | **~1000x** |
| **DBå†™å…¥** | 10-30åˆ†é’Ÿ | **1-2åˆ†é’Ÿ** | **~15x** |
| **æ€»ä½“æµç¨‹** | æ•°å°æ—¶ | **~2åˆ†é’Ÿ** | **~100x** |

### å†…å­˜å ç”¨

| æ“ä½œ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | è¯´æ˜ |
|------|--------|--------|------|
| **barcodeç´¢å¼•** | 0 MB | ~10 MB | 100Kæ¡ Ã— 100å­—èŠ‚/æ¡ |
| **æ‰¹é‡æŸ¥è¯¢ç¼“å­˜** | 0 MB | ~50 MB | 50Kæ¡ Ã— 1KB/æ¡ |
| **æ€»å¢é‡** | 0 MB | **~60 MB** | å¯æ¥å— |

---

## å®æ–½è®¡åˆ’

### é˜¶æ®µ1: Excelæ›´æ–°ä¼˜åŒ– (æœ€é«˜ä¼˜å…ˆçº§)

**å½±å“æ–‡ä»¶**:
- `src/core/douban/database/excel_updater.py`

**ä¿®æ”¹å†…å®¹**:
1. æ–°å¢ `_build_barcode_index()` æ–¹æ³•
2. é‡æ„ `update_from_database()` æ–¹æ³•
3. é‡æ„ `update_from_crawler()` æ–¹æ³•
4. æ ‡è®° `_find_row_index()` ä¸ºåºŸå¼ƒ

**æµ‹è¯•è¦ç‚¹**:
- âœ… åŠŸèƒ½æ­£ç¡®æ€§: æ›´æ–°ç»“æœä¸ä¼˜åŒ–å‰ä¸€è‡´
- âœ… æ€§èƒ½æµ‹è¯•: 10Wæ•°æ®æ›´æ–°æ—¶é—´ < 30ç§’
- âœ… è¾¹ç•Œæƒ…å†µ: ç©ºDataFrameã€é‡å¤barcodeã€ç¼ºå¤±barcodeåˆ—


---

### é˜¶æ®µ2: æ•°æ®åº“å†™å…¥ä¼˜åŒ–

**å½±å“æ–‡ä»¶**:
- `src/core/douban/database/database_manager.py`

**ä¿®æ”¹å†…å®¹**:
1. æ–°å¢ `batch_get_books_by_barcodes()` æ–¹æ³•
2. æ–°å¢ `_increment_version_in_memory()` æ–¹æ³•
3. é‡æ„ `_batch_save_books()` æ–¹æ³•
4. æ ‡è®° `_increment_data_version()` ä¸ºåºŸå¼ƒ

**æµ‹è¯•è¦ç‚¹**:
- âœ… ç‰ˆæœ¬å·é€’å¢é€»è¾‘æ­£ç¡®
- âœ… merge/overwriteæ¨¡å¼æ­£å¸¸å·¥ä½œ
- âœ… äº‹åŠ¡å®Œæ•´æ€§
- âœ… 10Wæ•°æ®å†™å…¥æ—¶é—´ < 5åˆ†é’Ÿ

---

### é˜¶æ®µ3: SQLå‚æ•°é™åˆ¶å¤„ç†

**å½±å“æ–‡ä»¶**:
- `src/core/douban/database/database_manager.py`

**ä¿®æ”¹å†…å®¹**:
1. é‡æ„ `batch_check_duplicates()` æ–¹æ³•,æ·»åŠ åˆ†æ‰¹é€»è¾‘

**æµ‹è¯•è¦ç‚¹**:
- âœ… 10Wæ¡barcodeæŸ¥é‡æˆåŠŸ
- âœ… åˆ†æ‰¹æŸ¥è¯¢ç»“æœå®Œæ•´
- âœ… æ€§èƒ½æµ‹è¯•: 10Wæ•°æ®æŸ¥é‡ < 10ç§’


---

### é˜¶æ®µ4: é›†æˆæµ‹è¯•ä¸æ€§èƒ½éªŒè¯

**æµ‹è¯•æ•°æ®é›†**:
- å°è§„æ¨¡: 1,000æ¡
- ä¸­è§„æ¨¡: 10,000æ¡
- å¤§è§„æ¨¡: 100,000æ¡

**æµ‹è¯•æŒ‡æ ‡**:
- æ‰§è¡Œæ—¶é—´
- å†…å­˜å ç”¨
- CPUä½¿ç”¨ç‡
- ç»“æœæ­£ç¡®æ€§


---

## é£é™©è¯„ä¼°

### é£é™©1: å†…å­˜å ç”¨å¢åŠ  ğŸŸ¡ ä¸­ç­‰é£é™©

**æè¿°**: 
- barcodeç´¢å¼•å’Œæ‰¹é‡æŸ¥è¯¢ç¼“å­˜ä¼šå¢åŠ å†…å­˜å ç”¨
- 10Wæ•°æ®çº¦å¢åŠ 60MBå†…å­˜

**ç¼“è§£æªæ–½**:
- ä½¿ç”¨å®Œæ¯•ååŠæ—¶æ¸…ç†ç´¢å¼•
- åˆ†æ‰¹å¤„ç†è¶…å¤§æ•°æ®é›† (å¦‚100W+)
- ç›‘æ§å†…å­˜ä½¿ç”¨æƒ…å†µ

**å½±å“**: ä½ - ç°ä»£è®¡ç®—æœº60MBå¯å¿½ç•¥

---

### é£é™©2: ä»£ç å…¼å®¹æ€§ ğŸŸ¢ ä½é£é™©

**æè¿°**:
- ä¿®æ”¹æ ¸å¿ƒæ–¹æ³•å¯èƒ½å½±å“ç°æœ‰è°ƒç”¨

**ç¼“è§£æªæ–½**:
- ä¿æŒæ–¹æ³•ç­¾åä¸å˜
- åºŸå¼ƒæ–¹æ³•ä¿ç•™å‘åå…¼å®¹
- å®Œæ•´çš„å•å…ƒæµ‹è¯•è¦†ç›–

**å½±å“**: ä½ - æ–¹æ³•ç­¾åæœªæ”¹å˜

---

### é£é™©3: æ•°æ®ä¸€è‡´æ€§ ğŸŸ¢ ä½é£é™©

**æè¿°**:
- æ‰¹é‡æŸ¥è¯¢å¯èƒ½é—æ¼éƒ¨åˆ†æ•°æ®

**ç¼“è§£æªæ–½**:
- å®Œæ•´çš„æ—¥å¿—è®°å½•
- å¯¹æ¯”ä¼˜åŒ–å‰åç»“æœ
- åˆ†æ‰¹æŸ¥è¯¢ç¡®ä¿å®Œæ•´æ€§

**å½±å“**: ä½ - é€»è¾‘ä¸¥æ ¼æµ‹è¯•

---

## å›æ»šæ–¹æ¡ˆ

### å¦‚æœä¼˜åŒ–åå‡ºç°é—®é¢˜

1. **ä¿ç•™åŸæ–¹æ³•**: åºŸå¼ƒæ–¹æ³•ä¸åˆ é™¤,ä»…æ ‡è®°
2. **é…ç½®å¼€å…³**: å¯é€šè¿‡é…ç½®åˆ‡æ¢æ–°æ—§å®ç°
3. **Gitå›æ»š**: ç‹¬ç«‹commit,ä¾¿äºå›æ»š

### å›æ»šæ­¥éª¤
```bash
# 1. å›æ»šåˆ°ä¼˜åŒ–å‰ç‰ˆæœ¬
git revert <commit_hash>

# 2. æˆ–ä½¿ç”¨é…ç½®å¼€å…³
# config/setting.yaml
database:
  use_optimized_excel_update: false  # åˆ‡æ¢å›æ—§å®ç°
```

---

## é™„å½•

### A. æ€§èƒ½æµ‹è¯•è„šæœ¬

```python
import time
import pandas as pd
from src.core.douban.database.excel_updater import ExcelUpdater

def benchmark_excel_update(excel_path, books_data, method='new'):
    """
    æ€§èƒ½æµ‹è¯•: Excelæ›´æ–°
    
    Args:
        excel_path: Excelæ–‡ä»¶è·¯å¾„
        books_data: æµ‹è¯•æ•°æ®
        method: 'old' æˆ– 'new'
    """
    updater = ExcelUpdater(excel_path)
    updater.load()
    
    start_time = time.time()
    
    if method == 'new':
        updater.update_from_database(books_data)
    else:
        # ä½¿ç”¨æ—§æ–¹æ³• (éœ€è¦ä¸´æ—¶æ¢å¤)
        pass
    
    elapsed = time.time() - start_time
    
    print(f"æ–¹æ³•: {method}")
    print(f"æ•°æ®é‡: {len(books_data)} æ¡")
    print(f"è€—æ—¶: {elapsed:.2f} ç§’")
    print(f"é€Ÿç‡: {len(books_data)/elapsed:.2f} æ¡/ç§’")
    
    return elapsed
```

### B. ç›¸å…³æ–‡æ¡£

- [å­—æ®µæ˜ å°„é…ç½®](../../config/setting.yaml)
- [æ€§èƒ½æµ‹è¯•æŠ¥å‘Š](./performance_test_report.md) (å¾…ç”Ÿæˆ)

---

**æ–‡æ¡£ç»“æŸ**
