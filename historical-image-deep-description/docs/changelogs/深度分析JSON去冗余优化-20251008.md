Status: In Progress

Objective / Summary
- 目的：优化 L3 深度分析的最终 JSON 结构，去除冗余的 subtopics[*].dify.results，统一以 children[*].dify 作为每题结果的唯一承载处，同时保留专题级聚合摘要 subtopics[*].dify.meta 与顶层 metadata.dify。
- 不改变逐题解析与逐个调用 Dify 的执行流程与策略（如 skip_if_executed 等），仅优化写入结构与渲染消费逻辑。

Scope
- 修改文件：
  - src/core/l3_deep_analysis/orchestrator.py：停止写入 s["dify"]["results"]；仅写 children[*].dify 与 s["dify"]["meta"]（摘要）。
  - src/core/l3_deep_analysis/report_writer.py：移除“回退兼容：使用 s['dify']['results'] 列表”的分支，仅按 children 渲染。
  - src/core/l3_deep_analysis/json_schema.py：成功判定规则以 children[*].dify.meta.status 为主，subtopic 级 meta 仅作为摘要，不再依赖 results。
- 测试新增：
  - tests/core/l3_deep_analysis/test_orchestrator_json_structure.py
  - tests/core/l3_deep_analysis/test_report_writer_rendering.py
  - 如有必要：tests/core/l3_deep_analysis/test_json_schema_validation.py

Detailed Plan
1) 生成器（orchestrator.py）
   - 初始化：
     - 若 s["dify"] 非 dict，则初始化为 {"meta": {}}（不含 results 字段）。
     - 若检测到旧结构 s["dify"]["results"] 存在，执行生成时不再写入该键；保留旧值但不再使用（下游渲染不读它）。
   - 逐题执行：
     - 保持原有 questions 解析与 call_dify 调用、题目级幂等与错误恢复策略。
     - 对每个问题，仅将结果写入对应 children 子节点：
       ch["dify"] = { "content": result.content or None, "meta": {executed_at,status,task_type,dify_response_id,error} }
     - 同步顶层 metadata.dify 记录每次执行日志（保持现状）。
   - 聚合摘要：
     - 汇总当次 subtopic 的执行状态，写入 s["dify"]["meta"] = {executed_at, status, task_type}。
     - 不再创建或追加 s["dify"]["results"]。
2) 渲染器（report_writer.py）
   - 删除“回退兼容：使用 s['dify']['results'] 列表”的分支逻辑。
   - 渲染时，仅迭代 children[*]，当 dify.meta.status == "success" 才输出内容。
   - 若 children 存在但无成功结果，则不输出 Dify 区块。
3) 校验器（json_schema.py）
   - 子主题成功判定：若 children 任一题目 dify.meta.status == "success" 则认为该子主题有成功结果。
   - subtopics[*].dify.meta 仅用于摘要展示，不作为唯一成功信号。
4) 迁移与兼容：
   - 新生成的 JSON 不再包含 s["dify"]["results"]，旧文件无需强制清理。
   - 所有下游消费者统一改读 children[*].dify；报告渲染不再读取 results。

Visualization
```mermaid
flowchart TD
    A[questions 解析] --> B{循环逐题}
    B -->|调用 Dify| C[call_dify(question, subtopic)]
    C --> D[格式化结果 result{content, meta}]
    D --> E[写入 children[*].dify]
    E --> F[专题级聚合 meta 摘要]
    F --> G[写入 subtopics[*].dify.meta]
    D --> H[写入顶层 metadata.dify 索引]
    %% 去冗余：不再写 subtopics[*].dify.results
    style G fill:#224466,stroke:#88aadd,color:#fff
    style E fill:#224422,stroke:#88ddaa,color:#fff
    style H fill:#333333,stroke:#999999,color:#fff
```

Testing Strategy
- 单元测试（tests/core/l3_deep_analysis/）
  - test_orchestrator_json_structure.py
    - 正常用例：给定含 2 个问题的 subtopic，执行后：
      - children 数量与 questions 对齐
      - 每个 children[*].dify.meta.status 为 "success"/"not_found"/"error" 按模拟结果一致
      - subtopics[*].dify 不包含 results 键，包含 meta 摘要
      - 顶层 metadata.dify 记录了调用日志条目数与问题名一致
    - 边界用例：部分问题失败或 not_found
      - children 的对应题目 meta.status 按预期
      - subtopic 汇总 meta.status 计算符合规则（有成功→success；仅错误→error；仅未找到→not_found）
    - 异常用例：call_dify 抛错
      - children[*].dify.content 为 None，meta.status="error"，error 字段存在
  - test_report_writer_rendering.py
    - 正常用例：仅按 children 渲染成功内容；不再读取 results
    - 边界用例：children 存在但均非 success → 不输出 Dify 区块
  - test_json_schema_validation.py（可选）
    - 检查新结构下的成功判定不依赖 results，仅依赖 children[*].dify.meta
- 集成测试（手动/脚本）
  - 跑一条完整 L3 流程，确认生成的 deep.json 不含 subtopics[*].dify.results，且报告生成正确。

Security Considerations
- 不记录敏感信息（API Key、Token 等）到 JSON 内容或日志。
- 日志仅使用中文语义化信息，避免泄露请求载荷中的敏感字段。

Notes
- 选择方案A：保留专题级摘要 subtopics[*].dify.meta，提升可读性与追踪性；同时消除 results 冗余，统一消费入口为 children[*].dify。
- 获批后将把 Status 更新为 In Progress，并开始实施与编写测试。