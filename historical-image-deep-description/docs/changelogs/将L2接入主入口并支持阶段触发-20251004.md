# 将 L2 接入主入口并支持阶段触发

Status: Implemented
Date: 2025-10-04

## Objective / Summary
- 在顶层 `main.py` 接入 L2（knowledge_linking）阶段：
  - 默认无参数时执行 L0 → L1 → L2。
  - `--tasks` 支持 L2 的整体开关与阶段粒度（build/classify/link/write），与 L0/L1 的现有机制保持一致。
- 主入口仅负责“是否执行 L2 以及是否透传阶段列表”；阶段解析与依赖补齐仍由 `src/core/l2_knowledge_linking/main.py::run_l2` 内部处理，保持低耦合。

## Scope
- 修改：
  - `main.py`
- 不修改（保持既有职责）：
  - `src/core/l2_knowledge_linking/main.py`（保留 `run_l2(excel_path=None, images_dir=None, limit=None, tasks=None)` 与内部阶段触发机制）
  - `src/core/l0_image_description/main.py`
  - `src/core/l1_structured_extraction/main.py`
  - `config/settings.yaml`（可选：未来用于覆盖 L2 阶段触发词与默认顺序）

## Detailed Plan
1) 默认执行顺序
- 在 `main.py` 默认分支（无 `--tasks`）中，L1 之后追加执行 L2：
  - `from src.core.l2_knowledge_linking.main import run as run_l2`
  - `run_l2(excel_path=None, images_dir=None, limit=args.limit, tasks=None)`（tasks=None → L2 内部按其默认顺序执行）

2) 扩展任务解析 `_parse_tasks`
- 现状：返回 `(l0_tasks: List[str], l1_enabled: bool, unknown: List[str])`
- 扩展：返回 `(l0_tasks: List[str], l1_enabled: bool, unknown: List[str], l2_enabled: bool, l2_phases: List[str])`
  - `l2_enabled`: 是否执行 L2
  - `l2_phases`: 要透传给 `run_l2(tasks=...)` 的阶段触发列表（可为空列表，表示使用 L2 默认顺序）
- 支持的任务词（大小写不敏感）：
  - 整体启用 L2：
    - 简名/别名：`knowledge_linking | l2 | l2_link`
    - 命名空间：`l2:knowledge_linking`
  - 指定 L2 阶段（可多选，去重保序）：
    - `l2:build`, `l2:classify`, `l2:link`, `l2:write`
- 解析规则：
  - 命名空间优先匹配：
    - 若出现 `l2:build/classify/link/write`，则视为选择相应阶段；设置 `l2_enabled=True` 且将阶段追加到 `l2_phases`。
    - 若出现 `l2:knowledge_linking`，则 `l2_enabled=True` 且不改动 `l2_phases`（保持为空 → 让 L2 内部按默认顺序运行）。
  - 简名/别名：
    - 命中 `knowledge_linking | l2 | l2_link` → `l2_enabled=True`（同上，不指定阶段）。
  - 未知项进入 `unknown`，仅 Warning，不中断。
- 兼容性：保留既有 L0/L1 的解析行为不变；仅新增 L2 分支与映射。

3) 执行顺序（与主编排文档保持一致）
- 无 `--tasks`：L0 全部 → L1 → L2。
- 有 `--tasks`：
  - 先执行 L0（若 `l0_tasks` 非空，则按顺序执行；否则跳过）。
  - 再执行 L1（若 `l1_enabled=True`）。
  - 最后执行 L2（若 `l2_enabled=True`）：
    - 若 `l2_phases` 为空：`run_l2(tasks=None)`（默认顺序）。
    - 若 `l2_phases` 非空：`run_l2(tasks=l2_phases)`（L2 内部负责依赖补齐与顺序扩展）。

4) 日志与可观测性
- 新增/使用以下日志键值（中文信息，避免敏感数据）：
  - `pipeline_default start=L0_all_then_L1_then_L2`
  - `pipeline_l2_enabled true phases=[...]`（当有指定阶段时）
  - `pipeline_l2_skipped reason=...`
  - `tasks_unknown items=[...]`（维持现有风格）
- 与 L2 内部现有日志互补（如：前置检查队列、阶段计划、写回状态等）。

5) 代码改动点（概述）
- `main.py`：
  - 扩展 `_ALIAS_TO_TARGET`：加入 L2 的整体别名映射（值形如 `("l2", "knowledge_linking")`）。
  - 扩展 `_parse_tasks`：解析 `l2_enabled` 与 `l2_phases`。
  - 默认分支中追加 L2 调用；有 `--tasks` 情况下在 L1 之后追加 L2 调用。
  - 仅在需要时延迟导入 `run_l1` 与 `run_l2`，避免模块加载开销。
- 不在主入口实现 L2 的阶段校验与依赖逻辑，避免重复实现；由 L2 内部负责。

## Visualization
```mermaid
flowchart TD
    A[入口 main.py] -->|无 --tasks| B[L0: long, alt, kw]
    B --> C[L1: structured]
    C --> H[L2: knowledge_linking (默认顺序)]
    A -->|--tasks 解析| D{任务解析}
    D -->|l0_tasks 非空| E[L0: 按顺序执行所选子任务]
    D -->|l1_enabled| F[L1: structured]
    D -->|l2_enabled| G{是否指定 L2 阶段}
    G -->|未指定| H[L2: 默认顺序]
    G -->|指定 phases| I[L2: 透传 phases 给 run_l2]
```

## Testing Strategy
- 手动验证：
  - `python main.py` → 观察顺序 L0 → L1 → L2；日志含 `pipeline_default start=L0_all_then_L1_then_L2`。
  - `python main.py --tasks "l2:knowledge_linking"` → 仅运行 L2（默认顺序）；日志包含 `pipeline_l0_skipped`、`pipeline_l1_skipped`、`pipeline_l2_enabled true`。
  - `python main.py --tasks "l2:build,l2:write"` → 仅运行 L2 指定阶段；日志包含 `pipeline_l2_enabled true phases=['build','write']`；L2 内部日志显示依赖补齐（自动补 `link` 如需要）。
  - `python main.py --tasks "alt_text,structured,l2:link"` → L0:alt_text → L1 → L2:link（L2 内部补齐依赖）。
  - 未知任务：`--tasks foo` → Warning 不中断。
- 自动化（可后续新增）：
  - 入口级测试：使用 `subprocess` 调用 `python main.py` 与不同参数组合，捕获标准输出/日志断言关键日志片段与退出码。
  - 单元级：对 `_parse_tasks` 增加用例，覆盖 L2 整体、阶段、多项、未知与混合场景。

## Security Considerations
- 不新增敏感参数；路径、模型、输出目录仍由现有配置读取。
- 日志仅输出选择的任务与阶段，避免记录敏感数据。

## Compatibility
- 向后兼容：
  - 旧用法 `python main.py` 仍可运行，但新增会执行 L2（符合 2025-10-02 的主入口编排文档）。
  - 旧 `--tasks` 仅含 L0/L1 名称的行为不变；新增支持 L2 的整体与阶段词。
- 不改变 L2 模块自身 CLI（`python -m src.core.l2_knowledge_linking.main --l2 "..."` 仅用于调试）。

## Implementation Notes
- 实现时保持最小改动：
  - 不引入新依赖；
  - 延迟导入 L1/L2 的 run 函数；
  - `_parse_tasks` 的新增返回值保证旧调用处不受影响（仅本文件内部调用）。
- 预计修改行数较少，集中在 `main.py`。